<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apogée du Duel HTML (Corrigé)</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #1a1a1a; overflow: hidden; font-family: Constantia, 'Lucida Bright', Lucidabright, 'Lucida Serif', Lucida, 'DejaVu Serif', 'Bitstream Vera Serif', 'Liberation Serif', Georgia, serif; color: #f0e8e0; }
        canvas { display: block; background-color: #141211; border: 5px inset #d4bca4; box-shadow: 0 0 40px rgba(212, 188, 164, 0.45); image-rendering: pixelated; image-rendering: crisp-edges; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; pointer-events: none; z-index: 10; }
        #game-info { position: absolute; top: 20px; width: 97%; max-width: 1024px; display: flex; justify-content: space-between; align-items: flex-start; font-size: 23px; text-shadow: 3px 3px 6px rgba(0,0,0,1); color: #fff5e1; }
        .player-ui { width: 45%; }
        .health-bar-container { width: 100%; height: 33px; background-color: rgba(100, 100, 100, 0.92); border: 3px groove #8d6e63; border-radius: 8px; overflow: hidden; position: relative; margin-bottom: 8px; box-shadow: inset 0 0 7px rgba(0,0,0,0.6); }
        .health-bar { height: 100%; width: 100%; transition: width 0.15s ease-out; }
        #player1-health-bar { background: linear-gradient(to right, #81c784, #dcedc8); }
        #player2-health-bar { background: linear-gradient(to right, #ff8a80, #ffebee); direction: rtl; }
        .special-bar-container { width: 75%; height: 14px; background-color: rgba(80, 80, 80, 0.88); border: 1px solid #6a6a6a; border-radius: 5px; overflow: hidden; box-shadow: inset 0 0 4px rgba(0,0,0,0.4); }
        .special-bar { height: 100%; width: 0%; background: linear-gradient(to right, #90caf9, #e3f2fd); transition: width 0.1s linear; }
        #player1-special-container { margin-top: 2px; margin-left: 0; }
        #player2-special-container { margin-top: 2px; margin-right: 0; display: flex; justify-content: flex-end;}
        #timer { font-size: 48px; font-weight: bold; color: #fffacd; background-color: rgba(20, 20, 20, 0.82); padding: 9px 22px; border-radius: 9px; border: 3px solid #d4b890; min-width: 85px; text-align: center; margin-top: 20px;}
        #message-center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; font-weight: 900; color: #FFECB3; text-align: center; text-shadow: 4px 4px 10px rgba(0,0,0,1); background: linear-gradient(145deg, rgba(109, 76, 65, 0.96) 0%, rgba(62, 39, 35, 0.98) 100%); padding: 35px 55px; border-radius: 20px; border: 6px outset #ffe9cb; display: none; line-height: 1.4; }
        #message-center.show { display: block; animation: popIn 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55); }
        #score-display { font-size: 24px; margin-top: 15px; color: #f5deb3; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        #combo-indicator { position: absolute; top: 160px; left: 50%; transform: translateX(-50%); font-size: 36px; color: #ffb300; font-weight: bold; text-shadow: 3px 3px 8px rgba(0,0,0,1); display: none; opacity: 0; transition: opacity 0.4s ease-out, top 0.4s ease-out; }
        #combo-indicator.show { display: block; opacity: 1; top: 125px; animation: comboSlam 0.45s ease-out; }
        @keyframes popIn { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        @keyframes comboSlam { 0% { transform: translateX(-50%) scale(0.8) rotate(-5deg); } 50% { transform: translateX(-50%) scale(1.15) rotate(5deg); } 100% { transform: translateX(-50%) scale(1) rotate(0deg); } }
    </style>
</head>
<body>
    <div id="ui-overlay"> <div id="game-info"> <div class="player-ui"> <div id="player1-health-container" class="health-bar-container"> <div id="player1-health-bar" class="health-bar"></div> </div> <div id="player1-special-container" class="special-bar-container"> <div id="player1-special-bar" class="special-bar"></div> </div> </div> <div id="timer">99</div> <div class="player-ui"> <div id="player2-health-container" class="health-bar-container" style="direction: rtl;"> <div id="player2-health-bar" class="health-bar"></div> </div> <div id="player2-special-container" class="special-bar-container"> <div id="player2-special-bar" class="special-bar"></div> </div> </div> </div> <div id="message-center"> Appuyez sur Entrée <div id="score-display"></div> </div> <div id="combo-indicator"></div> </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const player1HealthBar = document.getElementById('player1-health-bar');
        const player2HealthBar = document.getElementById('player2-health-bar');
        const player1SpecialBar = document.getElementById('player1-special-bar');
        const player2SpecialBar = document.getElementById('player2-special-bar');
        const timerElement = document.getElementById('timer');
        const messageCenter = document.getElementById('message-center');
        const scoreDisplay = document.getElementById('score-display');
        const comboIndicator = document.getElementById('combo-indicator');

        canvas.width = 1024; canvas.height = 576;

        const gravity = 0.88;
        const floorY = canvas.height - 70;
        const JUMP_VELOCITY = -22;
        const PLAYER_SPEED = 6.4;
        const BLOCKING_SPEED_MULTIPLIER = 0.4;
        const AI_SPEED = 5.0;
        const MAX_HEALTH = 100;
        const ATTACK_DAMAGE = 7;
        const COMBO_BONUS_DAMAGE = 4;
        const SPECIAL_ATTACK_DAMAGE = 18;
        const BLOCK_DAMAGE_REDUCTION = 0.85;
        const HEALTH_PICKUP_AMOUNT = 20;
        const ATTACK_COOLDOWN = 250;
        const AI_ATTACK_COOLDOWN = 340;
        const SPECIAL_COOLDOWN = 5000;
        const ATTACK_DURATION = 95;
        const ATTACK_SWING_DURATION = 125;
        const SPECIAL_ATTACK_DURATION = 350;
        const DASH_SPEED = 14.0;
        const PARRY_WINDOW = 80;
        const AI_STUN_DURATION = 400;
        const PARRY_SPECIAL_GAIN = 25;
        const GAME_DURATION = 99;
        const AI_REACTION_TIME = 90;
        const AI_ATTACK_PROBABILITY = 0.09;
        const AI_SPECIAL_PROBABILITY = 0.025;
        const AI_PICKUP_CHANCE = 0.07;
        const AI_EVADE_CHANCE = 0.18;
        const PARTICLE_COUNT = 14;
        const MAX_SPECIAL = 100;
        const SPECIAL_RECHARGE_RATE = 22;
        const PICKUP_SPAWN_INTERVAL = 12000;
        const SHAKE_DURATION = 110;
        const SHAKE_INTENSITY = 3.5;
        const HIT_LAG_DURATION = 55;
        const SCORE_HIT = 50; const SCORE_COMBO_MULTIPLIER = 10; const SCORE_PARRY = 150; const SCORE_WIN = 500; const SCORE_HEALTH_BONUS = 2; const SCORE_TIME_BONUS = 5;

        let player;
        let opponent;
        let timer = GAME_DURATION;
        let timerId;
        let keys = {};
        let gameState = 'MENU';
        let lastFrameTime = 0;
        // No global deltaTime needed, calculated locally in loop
        let aiActionTimeout = null;
        let particles = [];
        let pickups = [];
        let platforms = [];
        let foregroundElements = [];
        let attackVisuals = [];
        let lastPickupSpawnTime = 0;
        let worldWidth = canvas.width * 2.5;
        let camera = { x: 0, y: 0, targetX: 0 };
        let screenShake = { intensity: 0, duration: 0 };
        let gamePausedForHitLag = 0; // Milliseconds the game logic is paused
        let lastPlayerHitTime = 0;
        let playerComboCount = 0;
        let maxCombo = 0;
        let parryCount = 0;
        let hitCount = 0;
        let comboIndicatorTimeout;
        let gameIsOver = false;

        class Particle { // Unchanged
            constructor(x, y, color = '#FFA500', size = 3, speed = 3.5, life = 0.4, useGravity = true) { this.position = { x, y }; this.velocity = { x: (Math.random() - 0.5) * speed * 2, y: (Math.random() - 0.5) * speed * 2 - 1}; this.color = color; this.size = Math.random() * size + 1.2; this.life = life * (Math.random() * 0.4 + 0.8); this.initialLife = this.life; this.alpha = 1; this.useGravity = useGravity; }
            update(dt) { this.position.x += this.velocity.x * dt * 60; this.position.y += this.velocity.y * dt * 60; if (this.useGravity) this.velocity.y += gravity * 0.7 * dt * 60; this.life -= dt; this.alpha = Math.max(0, this.life / this.initialLife); }
            draw(offsetX) { ctx.globalAlpha = this.alpha * 0.9; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.position.x - offsetX, this.position.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
        }
        function emitParticles(x, y, count, color, size, speed, useGravity = true) { for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color, size, speed, useGravity)); }

        class Pickup { // Unchanged
             constructor(x, y, type = 'health'){ this.position = {x, y}; this.type = type; this.active = true; this.size = 23; this.bobOffset = 0; this.bobSpeed = 2.3; }
             update(dt){ if(!this.active) return; this.bobOffset = Math.sin(performance.now() / 165) * this.bobSpeed; }
             draw(offsetX){ if(!this.active) return; const drawX = this.position.x - offsetX; const drawY = this.position.y + this.bobOffset; if (this.type === 'health') { const grad = ctx.createRadialGradient(drawX, drawY, 1, drawX, drawY, this.size); grad.addColorStop(0, '#ffcdd2'); grad.addColorStop(1, '#e57373'); ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(drawX, drawY - this.size * 0.3); ctx.bezierCurveTo(drawX, drawY - this.size * 0.8, drawX - this.size * 0.7, drawY - this.size * 0.8, drawX - this.size * 0.7, drawY - this.size * 0.3); ctx.bezierCurveTo(drawX - this.size * 0.7, drawY + this.size * 0.2, drawX, drawY + this.size * 0.6, drawX, drawY + this.size * 0.6); ctx.bezierCurveTo(drawX, drawY + this.size * 0.6, drawX + this.size * 0.7, drawY + this.size * 0.2, drawX + this.size * 0.7, drawY - this.size * 0.3); ctx.bezierCurveTo(drawX + this.size * 0.7, drawY - this.size * 0.8, drawX, drawY - this.size * 0.8, drawX, drawY - this.size * 0.3); ctx.fill(); ctx.strokeStyle = '#d84315'; ctx.lineWidth=1; ctx.stroke(); } }
             checkCollision(sprite) { if (!this.active) return false; const dx = sprite.position.x + sprite.width / 2 - this.position.x; const dy = sprite.position.y + sprite.height / 2 - this.position.y; return Math.sqrt(dx * dx + dy * dy) < (sprite.width / 2 + this.size * 0.75); }
        }

        class Platform { // Unchanged
             constructor(x, y, width, height, style = 0){ this.position = {x,y}; this.width = width; this.height = height; this.style = style; this.colorTop = style === 0 ? '#a1887f' : '#bcaaa4'; this.colorBottom = style === 0 ? '#795548' : '#8d6e63';}
             draw(offsetX) { const drawX = this.position.x - offsetX; const grad = ctx.createLinearGradient(drawX, this.position.y, drawX, this.position.y + this.height); grad.addColorStop(0, this.colorTop); grad.addColorStop(1, this.colorBottom); ctx.fillStyle = grad; ctx.fillRect(drawX, this.position.y, this.width, this.height); ctx.strokeStyle = 'rgba(40,20,10,0.3)'; ctx.lineWidth = 1; ctx.strokeRect(drawX, this.position.y, this.width, this.height); }
        }

        class ForegroundElement { // Unchanged
            constructor(x, y, width, height, type='pillar'){ this.position = {x, y}; this.width=width; this.height=height; this.type=type; this.color1='#8d6e63'; this.color2='#6d4c41'; this.color3='#bcaaa4';}
            draw(offsetX){ const drawX = this.position.x - offsetX; const drawY = this.position.y; if(this.type === 'pillar'){ ctx.fillStyle = this.color1; ctx.fillRect(drawX, drawY + 15, this.width, this.height - 35); ctx.fillStyle = this.color2; ctx.fillRect(drawX - 7, drawY + this.height - 25, this.width + 14, 25); ctx.fillRect(drawX - 7, drawY, this.width + 14, 15); ctx.fillStyle = this.color3; ctx.fillRect(drawX-2, drawY+15, this.width+4, 6); ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(drawX + this.width * 0.6, drawY + 15, this.width * 0.4, this.height-35); ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(drawX, drawY + 15, this.width * 0.25, this.height-35); }}
        }

        class AttackVisual { // Unchanged
             constructor(attacker, box, duration){ this.attacker = attacker; this.box = { ...box }; this.duration = duration; this.life = duration; this.facingRight = attacker.facingRight; }
             update(dt){ this.life -= dt * 1000;}
             draw(offsetX){ if(this.life <= 0) return; const progress = 1 - (this.life / this.duration); const alpha = Math.sin(progress * Math.PI) * 0.6; ctx.globalAlpha = alpha; const boxDrawX = this.box.position.x - offsetX; const flashColor = progress < 0.3 ? 'rgba(255, 255, 220, 0.9)' : 'rgba(255, 255, 180, 0.7)'; ctx.fillStyle = flashColor; ctx.fillRect(boxDrawX, this.box.position.y, this.box.width, this.box.height); const centerX = this.attacker.position.x + this.attacker.width / 2 - offsetX; const centerY = this.attacker.position.y + this.attacker.height * 0.35; const radius = this.box.width * 0.9; const startAngle = this.facingRight ? -Math.PI * 0.25 : Math.PI * 1.25; const endAngle = this.facingRight ? Math.PI * 0.55 : Math.PI * 0.45; const currentAngle = this.facingRight ? startAngle + (endAngle-startAngle)*progress : startAngle - (startAngle-endAngle)*progress ; ctx.beginPath(); ctx.lineWidth = 8; ctx.strokeStyle = 'rgba(255, 255, 240, 0.75)'; ctx.arc(centerX, centerY, radius, this.facingRight ? startAngle : currentAngle, this.facingRight ? currentAngle : startAngle, !this.facingRight); ctx.stroke(); ctx.globalAlpha = 1.0; }
        }

        class Sprite { // Key definition for block added in constructor
            constructor({ position, velocity, color = '#607d8b', opponentColor = '#a1887f', dimensions = { width: 46, height: 140 }, attackBox = { offset: { x: 36, y: 30 }, width: 90, height: 45 }, specialAttackBox = { offset: { x: 46, y: 26}, width: 110, height: 58}, health = MAX_HEALTH, controls = {}, isAI = false, playerRef = null, variation = 1 }) {
                this.position = position; this.velocity = velocity; this.dimensions = dimensions; this.height = this.dimensions.height; this.width = this.dimensions.width;
                this.baseColor = color; this.opponentColor = opponentColor; this.variation = variation;
                this.attackBox = { position: { x: 0, y: 0 }, offset: attackBox.offset, width: attackBox.width, height: attackBox.height };
                this.specialAttackBox = { position: { x: 0, y: 0 }, offset: specialAttackBox.offset, width: specialAttackBox.width, height: specialAttackBox.height };
                this.isAttacking = false; this.isPerformingSpecial = false; this.specialDash = false; this.attackTimeout = null; this.specialTimeout = null; this.attackCooldownTimeout = null; this.specialCooldownTimeout = null;
                this.isBlocking = false; this.parryWindowActive = false; this.blockStartTime = 0; this.isStunned = false; this.stunTimeout = null;
                this.canAttack = true; this.canUseSpecial = true; this.canBlock = true; this.currentSpecial = 0; this.health = health; this.isGrounded = false; this.currentPlatform = null; this.lastkey = ''; this.controls = controls; this.facingRight = true; this.isAI = isAI; this.playerRef = playerRef; this.currentAIAction = null; this.aiDecisionTimer = 0; this.aiTarget = null; this.attackRange = this.attackBox.width * 1.1; this.lastHitTime = 0; this.aiIsEvading = false;
            }
             drawCharacter(offsetX) { // Unchanged drawing logic from previous
                 const x = this.position.x - offsetX; const y = this.position.y; const w = this.width; const h = this.height; const headSize = w * 0.45; const torsoHeight = h * 0.37; const legHeight = h * 0.39; const armWidth = w * 0.21; const armHeight = h * 0.45; const color = this.isAI ? this.opponentColor : this.baseColor; const detailColor = this.variation === 1 ? '#eceff1' : '#fff3e0'; const blockOffset = (this.isBlocking || this.isStunned) ? w * 0.1 : 0; const armBlockOffset = this.isBlocking ? -h*0.05 : 0;
                  ctx.fillStyle = color; const headX = (this.facingRight ? x + w * 0.24 : x + w * 0.31) - blockOffset * (this.facingRight ? -1:1); ctx.fillRect(headX, y, headSize, headSize * 1.1); ctx.fillStyle = detailColor; ctx.fillRect(headX + headSize * 0.1, y + headSize * 0.45, headSize * 0.8, headSize * 0.18); ctx.fillStyle = color; const torsoX = (x + w * 0.07) - blockOffset * (this.facingRight ? -1:1); const torsoY = y + headSize*1.1; ctx.fillRect(torsoX, torsoY, w * 0.86, torsoHeight); ctx.fillStyle = detailColor; ctx.fillRect(torsoX, torsoY + torsoHeight * 0.8, w * 0.86, torsoHeight * 0.15); ctx.fillStyle = color; const legY = torsoY + torsoHeight; const legWidth = w * 0.33; ctx.fillRect(torsoX, legY, legWidth, legHeight); ctx.fillRect(torsoX + w * 0.53, legY, legWidth, legHeight); const armY = torsoY + torsoHeight * 0.05 + armBlockOffset; if (this.facingRight) ctx.fillRect( (x + w * 0.85) - blockOffset , armY, armWidth, armHeight); else ctx.fillRect( (x - w * 0.06) - blockOffset, armY, armWidth, armHeight); const highlightY = y; const highlightHeight = h * 0.4; ctx.fillStyle = 'rgba(255, 255, 255, 0.09)'; ctx.fillRect(x- blockOffset*(this.facingRight?-1:1), highlightY, w, highlightHeight);
                 if(this.isStunned) { const stunX = x + w / 2; const stunY = y - 15; ctx.fillStyle = 'rgba(255, 255, 0, 0.7)'; for(let i = 0; i < 3; i++){ const angle = (performance.now() / 150 + i * Math.PI * 2 / 3); ctx.beginPath(); ctx.arc(stunX + Math.cos(angle) * 15, stunY + Math.sin(angle) * 15, 4, 0, Math.PI*2); ctx.fill(); } }
                 if (this.isBlocking) { ctx.globalAlpha = 0.3 + Math.sin(performance.now() / 100) * 0.1; ctx.fillStyle = '#afeeee'; ctx.beginPath(); ctx.ellipse(x + (this.facingRight ? w * 0.8 : w * 0.2), y + h * 0.3, w*0.6, h*0.5, 0, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; }
                  if(this.isPerformingSpecial && this.specialDash){ ctx.fillStyle = 'rgba(64, 224, 208, 0.45)'; ctx.beginPath(); ctx.arc(x + this.width/2, y + this.height/2, this.width*1.15, 0, Math.PI * 2); ctx.fill(); } else if (this.currentSpecial === MAX_SPECIAL) { ctx.fillStyle = 'rgba(0, 200, 255, 0.18)'; ctx.beginPath(); ctx.arc(x + this.width/2, y + this.height/2, this.width * 0.75, 0, Math.PI * 2); ctx.fill(); }
             }

            update(dt, platforms) { // Unchanged update logic from previous (robust version)
                 if (this.isStunned) { this.velocity.x=0; this.velocity.y += gravity*dt*60; this.position.y += this.velocity.y*dt*60; return; }
                  this.currentSpecial = Math.min(MAX_SPECIAL, this.currentSpecial + SPECIAL_RECHARGE_RATE * dt); this.updateSpecialBar();
                  if (!this.isAI) this.handleInput(); else this.updateAI(dt, platforms);
                  const speedMultiplier = this.isBlocking ? BLOCKING_SPEED_MULTIPLIER : 1; const prevY = this.position.y; this.position.x += this.velocity.x * dt * 60 * speedMultiplier;
                 if (this.position.x <= 0) this.position.x = 0; if (this.position.x + this.width >= worldWidth) this.position.x = worldWidth - this.width;
                  if (!this.specialDash && !this.aiIsEvading) { this.velocity.y += gravity; this.position.y += this.velocity.y * dt * 60; this.currentPlatform = null; let landed = false; for(const platform of platforms){ if ( this.velocity.y >= 0 && this.position.x + this.width > platform.position.x && this.position.x < platform.position.x + platform.width && prevY + this.height <= platform.position.y + 1 && this.position.y + this.height >= platform.position.y ) { this.velocity.y = 0; this.position.y = platform.position.y - this.height; this.isGrounded = true; this.currentPlatform = platform; landed = true; if(!this.isBlocking) emitParticles(this.position.x + this.width / 2, this.position.y + this.height, 3, '#a1887f', 2.5, 1.2); break; }} if (!landed && this.position.y + this.height >= floorY) { if (this.velocity.y > 1 && !this.isBlocking) emitParticles(this.position.x + this.width / 2, this.position.y + this.height, 4, '#8d6e63', 3, 1.8); this.velocity.y = 0; this.position.y = floorY - this.height; this.isGrounded = true; landed = true; } if (!landed) { this.isGrounded = false; this.currentPlatform = null;}}
                 else if(this.specialDash) { this.position.x += this.velocity.x * dt * 60; if (this.position.x <= 0 || this.position.x + this.width >= worldWidth) { this.specialDash = false; this.velocity.x = 0;} }
                 else if (this.aiIsEvading) { this.position.x += this.velocity.x * dt * 60; this.position.y += this.velocity.y * dt * 60; }
                 if(this.isBlocking && performance.now() - this.blockStartTime < PARRY_WINDOW) this.parryWindowActive = true; else this.parryWindowActive = false;
                  let attackBoxOffsetX = this.facingRight ? this.attackBox.offset.x : -(this.attackBox.offset.x + this.attackBox.width - this.width); this.attackBox.position.x = this.position.x + attackBoxOffsetX; this.attackBox.position.y = this.position.y + this.attackBox.offset.y; let specialAttackBoxOffsetX = this.facingRight ? this.specialAttackBox.offset.x : -(this.specialAttackBox.offset.x + this.specialAttackBox.width - this.width); this.specialAttackBox.position.x = this.position.x + specialAttackBoxOffsetX; this.specialAttackBox.position.y = this.position.y + this.specialAttackBox.offset.y;
                 if (this.health <= 0) { this.health = 0; this.velocity.x = 0; this.canAttack = false; this.canUseSpecial = false; this.isBlocking=false;}
            }

            handleInput() { // Unchanged handleInput from previous (robust version)
                  if(this.health <= 0 || this.isPerformingSpecial || this.isStunned) { if(!this.isPerformingSpecial) this.velocity.x = 0; return;} if(keys[this.controls.block]) { if(!this.isBlocking && this.canBlock && this.isGrounded){ this.isBlocking = true; this.blockStartTime = performance.now(); this.canAttack = false; this.canUseSpecial = false; this.velocity.x = 0; }} else { if(this.isBlocking){ this.isBlocking = false; this.parryWindowActive = false; this.canAttack = true; this.canUseSpecial = true; }}
                   if (!this.isBlocking) { this.velocity.x = 0; if (keys[this.controls.left] && this.lastkey === this.controls.left) { this.velocity.x = -PLAYER_SPEED; this.facingRight = false; } else if (keys[this.controls.right] && this.lastkey === this.controls.right) { this.velocity.x = PLAYER_SPEED; this.facingRight = true; } if (keys[this.controls.jump] && this.isGrounded) { this.velocity.y = JUMP_VELOCITY; this.isGrounded = false; this.currentPlatform = null; emitParticles(this.position.x + this.width / 2, this.position.y + this.height, 4, '#b08d57', 3.5, 1.5); keys[this.controls.jump] = false; } if (keys[this.controls.attack] && this.canAttack) { this.attack(); keys[this.controls.attack] = false; } if (keys[this.controls.special] && this.canUseSpecial && this.currentSpecial === MAX_SPECIAL) { this.performSpecial(); keys[this.controls.special] = false; }}
             }
            updateAI(dt, platforms) { // Unchanged updateAI from previous (robust version)
                   if(this.health <= 0 || !this.playerRef || this.playerRef.health <= 0 || this.isPerformingSpecial || this.aiIsEvading || this.isStunned) { if (!this.isPerformingSpecial && !this.aiIsEvading && !this.isStunned) this.velocity.x=0; this.aiTarget=null; return; } this.aiDecisionTimer -= dt * 1000; const player = this.playerRef; const distanceX = Math.abs(player.position.x - this.position.x); if (player.isPerformingSpecial && player.specialDash && distanceX < canvas.width * 0.45 && !this.isAttacking && Math.random() < AI_EVADE_CHANCE) { this.aiEvade(); return; } if (this.aiDecisionTimer <= 0) { this.aiTarget = player.position; let closestPickup = null; let distToPickup = Infinity; if (pickups.some(p=>p.active && p.type==='health')) { pickups.filter(p=>p.active).forEach(p => { let d = Math.abs(p.position.x - this.position.x); if (d < distToPickup && Math.abs(p.position.y - this.position.y) < canvas.height*0.7) { distToPickup = d; closestPickup = p;}}); if (closestPickup && this.health < MAX_HEALTH * 0.7 && distanceX > canvas.width*0.2 && Math.random() < AI_PICKUP_CHANCE){ this.aiTarget = closestPickup.position; this.currentAIAction = 'seek_pickup'; } } const targetDirectionX = this.aiTarget.x - this.position.x; const targetDistanceX = Math.abs(targetDirectionX); const targetIsPlayer = this.aiTarget === player.position; const distanceY = Math.abs(player.position.y - this.position.y); const randomAction = Math.random(); let targetPlatform = targetIsPlayer ? player.currentPlatform : null; let needsJump = false; let jumpTargetPlatform = null; if ( (targetPlatform && this.currentPlatform !== targetPlatform && this.isGrounded) || (targetIsPlayer && player.position.y < this.position.y - this.height*0.8 && targetDistanceX < this.width * 4 && this.isGrounded) ) { needsJump = true; let bestPlatform = targetPlatform; if (!bestPlatform) { let minDist = Infinity; platforms.forEach(p => { let d = Math.abs((p.position.x + p.width/2) - (this.position.x + this.width/2)); if (p.position.y < this.position.y && d < minDist * 1.5 && Math.sign(p.position.x - this.position.x) === Math.sign(targetDirectionX)) { minDist = d; bestPlatform = p; }}); jumpTargetPlatform = bestPlatform; } else { jumpTargetPlatform = bestPlatform;}} const isPlayerBlocking = targetIsPlayer && player.isBlocking; if (needsJump && jumpTargetPlatform && randomAction < 0.4) { const jumpDir = (jumpTargetPlatform.position.x + jumpTargetPlatform.width / 2) > this.position.x ? 1 : -1; this.velocity.y = JUMP_VELOCITY * (jumpTargetPlatform.position.y < this.position.y - 180 ? 1.0 : 0.9); this.velocity.x = jumpDir * AI_SPEED; this.isGrounded = false; this.currentPlatform = null; this.facingRight = jumpDir > 0; emitParticles(this.position.x + this.width / 2, this.position.y + this.height, 3, '#b08d57', 3, 1); this.currentAIAction = 'platform_jump'; } else if (targetIsPlayer && !isPlayerBlocking && this.canUseSpecial && this.currentSpecial === MAX_SPECIAL && distanceX < canvas.width * 0.6 && distanceY < this.height * 1.4 && randomAction < AI_SPECIAL_PROBABILITY) { this.performSpecial(); this.currentAIAction = 'special'; } else if (targetIsPlayer && !isPlayerBlocking && distanceX < this.attackRange && distanceY < this.height * 1.1 && this.canAttack && randomAction < AI_ATTACK_PROBABILITY) { this.attack(); this.currentAIAction = 'attack'; } else if (targetDistanceX > this.width * (targetIsPlayer ? (isPlayerBlocking ? 2.5 : 1.7) : 0.8) ) { this.velocity.x = targetDirectionX > 0 ? AI_SPEED : -AI_SPEED; this.facingRight = targetDirectionX > 0; this.currentAIAction = 'move_target'; } else if (targetIsPlayer && distanceX < this.width * (isPlayerBlocking ? 1.5 : 0.9)) { this.velocity.x = targetDirectionX > 0 ? -AI_SPEED * 0.8 : AI_SPEED * 0.8; this.facingRight = !(targetDirectionX > 0); this.currentAIAction = 'retreat'; } else { this.velocity.x = 0; this.facingRight = targetDirectionX > 0; if(this.isGrounded && targetIsPlayer && !isPlayerBlocking && randomAction > 0.988) { this.velocity.y = JUMP_VELOCITY*0.5;} else {this.currentAIAction = 'idle';} } this.aiDecisionTimer = AI_REACTION_TIME + Math.random() * 70; }
             }
            aiEvade() { // Unchanged
                 this.currentAIAction = 'evade'; this.aiIsEvading = true; this.velocity.y = JUMP_VELOCITY * 0.65; this.velocity.x = this.playerRef.facingRight ? -PLAYER_SPEED * 0.85 : PLAYER_SPEED * 0.85; this.isGrounded = false; this.currentPlatform = null; emitParticles(this.position.x + this.width / 2, this.position.y + this.height, 6, '#f0f8ff', 3.5, 3, false); setTimeout(() => { this.aiIsEvading = false; this.velocity.x=0; }, 280);
            }
            attack() { // Unchanged
                if (!this.canAttack || this.isAttacking || this.isPerformingSpecial || this.isBlocking || this.isStunned) return; this.isAttacking = true; this.canAttack = false; this.velocity.x *= 0.05; attackVisuals.push(new AttackVisual(this, this.attackBox, ATTACK_SWING_DURATION)); clearTimeout(this.attackTimeout); this.attackTimeout = setTimeout(() => { this.isAttacking = false; }, ATTACK_DURATION); const cooldown = this.isAI ? AI_ATTACK_COOLDOWN : ATTACK_COOLDOWN; clearTimeout(this.attackCooldownTimeout); this.attackCooldownTimeout = setTimeout(() => { this.canAttack = true; }, cooldown + Math.random() * 20);
             }
            performSpecial() { // Unchanged
                if(!this.canUseSpecial || this.isPerformingSpecial || this.currentSpecial < MAX_SPECIAL || this.isBlocking || this.isStunned) return; this.isPerformingSpecial = true; this.canUseSpecial = false; this.currentSpecial = 0; this.specialDash = true; this.velocity.y = -3.5; this.velocity.x = this.facingRight ? DASH_SPEED : -DASH_SPEED; emitParticles(this.position.x + this.width/2, this.position.y + this.height*0.4, 22, '#b3e5fc', 4.5, 4.5, false); emitParticles(this.position.x + this.width/2, this.position.y + this.height*0.4, 35, '#ffffff', 2.5, 7, false); clearTimeout(this.specialTimeout); this.specialTimeout = setTimeout(() => { this.isPerformingSpecial = false; this.specialDash = false; this.velocity.x = 0; }, SPECIAL_ATTACK_DURATION); clearTimeout(this.specialCooldownTimeout); this.specialCooldownTimeout = setTimeout(() => { this.canUseSpecial = true; }, SPECIAL_COOLDOWN);
            }
             parrySuccess(attacker) { // Unchanged
                this.currentSpecial = Math.min(MAX_SPECIAL, this.currentSpecial + PARRY_SPECIAL_GAIN); this.updateSpecialBar(); emitParticles(this.position.x + this.width/2, this.position.y + this.height/2, 25, '#00ffff', 5, 7, false); emitParticles(this.position.x + this.width/2, this.position.y + this.height/2, 15, '#ffffff', 3, 5, false); parryCount++; if(attacker){ attacker.stun(); } this.isBlocking = false; this.parryWindowActive = false; this.canAttack = true; this.canUseSpecial = true;
            }
             stun() { // Unchanged
                  this.isStunned = true; this.isAttacking = false; this.isPerformingSpecial = false; this.isBlocking = false; this.canAttack = false; this.canUseSpecial=false; this.velocity.x = 0; this.velocity.y = -3; clearTimeout(this.stunTimeout); this.stunTimeout = setTimeout(() => { this.isStunned = false; this.canAttack = true; this.canUseSpecial = true; }, AI_STUN_DURATION);
              }
             takeHit(damage, isSpecial = false, attacker = null) { // Unchanged robust takeHit logic
                if (this.health <= 0 || this.isStunned) return false; if(!this.isAI && this.parryWindowActive && !isSpecial && attacker && attacker.isAttacking){ this.parrySuccess(attacker); return false; } let finalDamage = damage; if (!this.isAI && this.isBlocking && !isSpecial) { finalDamage *= (1 - BLOCK_DAMAGE_REDUCTION); emitParticles(this.position.x + this.width / 2, this.position.y + this.height / 2, PARTICLE_COUNT * 0.6, '#87CEEB', 4.5, 3.5, false); this.velocity.y = -2.5; } else { emitParticles(this.position.x + this.width / 2, this.position.y + this.height / 2, isSpecial ? PARTICLE_COUNT * 3.2 : PARTICLE_COUNT * 1.4, isSpecial ? '#ff6f6f' : '#ffcc80', isSpecial ? 7.5: 5.5, isSpecial ? 8.5: 6.5); this.velocity.y = -6.5; if(isSpecial) triggerScreenShake(); triggerHitLag(); } this.health -= finalDamage; if (this.health < 0) this.health = 0; this.updateHealthBar(); this.lastHitTime = performance.now(); if(!this.isAI){ playerComboCount = 0; showCombo(0); } return true;
             }

             updateHealthBar() { (this.isAI ? player2HealthBar : player1HealthBar).style.width = `${Math.max(0, this.health / MAX_HEALTH) * 100}%`; }
             updateSpecialBar() { (this.isAI ? player2SpecialBar : player1SpecialBar).style.width = `${(this.currentSpecial / MAX_SPECIAL) * 100}%`; }
             collectPickup(pickup) { if(pickup.type === 'health') { this.health = Math.min(MAX_HEALTH, this.health + HEALTH_PICKUP_AMOUNT); this.updateHealthBar(); emitParticles(this.position.x+this.width/2, this.position.y+this.height/2, 22, '#b9f6ca', 5.5, 4.5, false); } pickup.active = false; }
        } // End Sprite Class


        function triggerHitLag() { if (gamePausedForHitLag <= 0) gamePausedForHitLag = HIT_LAG_DURATION; }
        function triggerScreenShake(){ if(gamePausedForHitLag <= 0) {screenShake.duration = SHAKE_DURATION; screenShake.intensity = SHAKE_INTENSITY;}}
        function rectangularCollision({ attacker, target }) { let attacking = attacker.isAttacking || (attacker.isPerformingSpecial && !attacker.specialDash); if (!attacking || attacker.isStunned || target.isStunned) return false; let box = attacker.isPerformingSpecial ? attacker.specialAttackBox : attacker.attackBox; return ( box.position.x + box.width >= target.position.x && box.position.x <= target.position.x + target.width && box.position.y + box.height >= target.position.y && box.position.y <= target.position.y + target.height ); }
        function checkSpecialDashCollision({ attacker, target }){ if (!attacker.isPerformingSpecial || !attacker.specialDash || attacker.isStunned || target.isStunned) return false; return ( attacker.position.x + attacker.width > target.position.x && attacker.position.x < target.position.x + target.width && attacker.position.y + attacker.height > target.position.y && attacker.position.y < target.position.y + target.height ); }
        function updateCamera(dt) { const target = (opponent.health > 0) ? (player.position.x + opponent.position.x) / 2 : player.position.x + player.width / 2; camera.targetX = target - canvas.width / 2; camera.targetX = Math.max(0, Math.min(camera.targetX, worldWidth - canvas.width)); camera.x += (camera.targetX - camera.x) * 0.11; if (Math.abs(camera.targetX - camera.x) < 0.5) camera.x = camera.targetX; }

         function drawBackground(offsetX){ // Uses stable hash-based colors now
             ctx.fillStyle = '#5d4037'; ctx.fillRect(0, 0, canvas.width, canvas.height); const parallaxFactor = 0.4; const parallaxOffsetX = offsetX * parallaxFactor; ctx.strokeStyle = 'rgba(40, 20, 10, 0.25)'; ctx.lineWidth = 1.8;
              const hash = (x, y) => { let h = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453; return h - Math.floor(h); }; // Simple hash
              const getColor = (val) => val < 0.33 ? '#6d4c41' : (val < 0.66 ? '#5d4037' : '#795548');
              const getBannerColor = (val) => val < 0.5 ? '#d32f2f' : '#1565c0';

              for (let y = 0; y < floorY + 70; y += 100) { for (let x = -(parallaxOffsetX % 160) - 160; x < canvas.width + (parallaxOffsetX % 160) + 160; x += 160) { const drawX = x - (parallaxOffsetX > 0 ? parallaxOffsetX % 160 : 0); const worldX = Math.floor((drawX + parallaxOffsetX) / 160); const worldY = Math.floor(y / 100);
                 const h = hash(worldX, worldY); const hc = hash(worldX+1, worldY+1); const hb = hash(worldX+2, worldY+2);
                  ctx.fillStyle = getColor(h); ctx.fillRect(drawX , y, 160, 100); ctx.strokeRect(drawX , y, 160, 100);
                 if( hc < 0.12 ) { ctx.fillStyle = '#4e342e'; ctx.fillRect(drawX + 65, y + 28, 30, 65); ctx.fillStyle='#5d4037';ctx.fillRect(drawX+70,y+33,20,55); }
                 else if ( hb < 0.1 ) { ctx.fillStyle = getBannerColor(h); ctx.fillRect(drawX + 70, y + 12, 20, 80); ctx.fillStyle = '#ffda63'; ctx.fillRect(drawX + 75, y+17, 10, 10); }}}
              ctx.fillStyle = '#a1887f'; ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY); ctx.fillStyle = 'rgba(0,0,0,0.14)'; for(let i = 0; i < canvas.width; i += 65){ ctx.fillRect(i, floorY, 2, canvas.height - floorY); } ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,floorY, canvas.width, 7);
         }

         function showCombo(count) { if (count < 2) { comboIndicator.classList.remove('show'); return; } comboIndicator.textContent = `COMBO x ${count}!`; maxCombo = Math.max(maxCombo, count); comboIndicator.classList.add('show'); clearTimeout(comboIndicatorTimeout); comboIndicatorTimeout = setTimeout(() => { comboIndicator.classList.remove('show'); }, 1100); }
        function calculateScore() { let score = 0; score += hitCount * SCORE_HIT; score += maxCombo * SCORE_COMBO_MULTIPLIER * 10; score += parryCount * SCORE_PARRY; if(player.health > 0 && opponent.health <= 0) score += SCORE_WIN; else if (player.health > opponent.health && timer <= 0) score += SCORE_WIN / 2; score += Math.max(0, player.health * SCORE_HEALTH_BONUS); if (player.health > 0 && opponent.health <= 0) score += Math.max(0, timer * SCORE_TIME_BONUS); return Math.floor(score); }

        function resetGame() { // Added key mapping for block
            particles = []; pickups = []; platforms = []; foregroundElements = []; attackVisuals = []; gameIsOver = false; maxCombo = 0; parryCount = 0; hitCount = 0;
            worldWidth = canvas.width * 2.5; const platformData = [ [worldWidth*0.25, canvas.height-180, 280, 20, 0], [worldWidth*0.75-300, canvas.height-180, 280, 20, 0], [worldWidth*0.5-200, canvas.height-350, 400, 25, 1], [worldWidth*0.1, canvas.height-420, 150, 20, 0], [worldWidth*0.9-150, canvas.height-420, 150, 20, 0], [worldWidth*0.4, floorY-110, 120, 15, 1],[worldWidth*0.6-120, floorY-110, 120, 15, 1] ]; platformData.forEach(p => platforms.push(new Platform(p[0], p[1], p[2], p[3], p[4]))); foregroundElements.push(new ForegroundElement(worldWidth * 0.12, floorY - 270, 50, 270)); foregroundElements.push(new ForegroundElement(worldWidth * 0.88 - 50, floorY - 270, 50, 270));
            player = new Sprite({ position: { x: worldWidth*0.1-30, y: floorY-150 }, velocity: { x: 0, y: 0 }, color: '#81d4fa', controls: { left: 'q', right: 'd', jump: 'z', attack: 'f', special: 'e', block: 'shift' }, variation: 1 }); player.facingRight = true;
            opponent = new Sprite({ position: { x: worldWidth*0.9-30, y: floorY-150 }, velocity: { x: 0, y: 0 }, opponentColor: '#ffcc80', isAI: true, playerRef: player, variation: 2 }); opponent.facingRight = false;
            player.health=MAX_HEALTH; opponent.health=MAX_HEALTH; player.currentSpecial=0; opponent.currentSpecial=0; player.currentPlatform=null; opponent.currentPlatform=null; player.isBlocking=false; player.isStunned=false; opponent.isStunned=false;
            player.updateHealthBar(); opponent.updateHealthBar(); player.updateSpecialBar(); opponent.updateSpecialBar(); playerComboCount=0; comboIndicator.classList.remove('show'); gamePausedForHitLag=0; scoreDisplay.innerHTML = '';
            camera.x = (player.position.x + opponent.position.x)/2 - canvas.width / 2; camera.x = Math.max(0, Math.min(camera.x, worldWidth - canvas.width)); camera.targetX = camera.x;
            timer = GAME_DURATION; timerElement.textContent = timer; clearTimeout(timerId); clearTimeout(aiActionTimeout); keys = {}; lastPickupSpawnTime = performance.now(); screenShake = { intensity: 0, duration: 0 };
        }

        function gameLoop(currentTime) {
            // Calculate elapsed time since last fully processed frame
            const elapsed = currentTime - lastFrameTime;
            // Calculate clamped delta time based on elapsed time
            const dt = Math.min(0.033, Math.max(0.001, elapsed / 1000)); // Clamped dt

             // Check if the game logic should be paused for hit lag
             let updateLogic = true;
             if (gamePausedForHitLag > 0) {
                 gamePausedForHitLag -= elapsed; // Decrement pause timer by actual elapsed time
                 if (gamePausedForHitLag > 0) {
                     updateLogic = false; // Still paused, skip updates
                 } else {
                      // Pause finished THIS frame. Logic can run, reset pause timer.
                     gamePausedForHitLag = 0;
                 }
             }

             // ---- Update Logic ---- (Only runs if updateLogic is true)
             if (updateLogic) {
                 lastFrameTime = currentTime; // Mark this time as the last frame where logic was fully processed

                 if (gameState === 'PLAYING' && !gameIsOver) {
                     updateCamera(dt); player.update(dt, platforms); opponent.update(dt, platforms);
                     particles.forEach((p, index) => { p.update(dt); if(p.life <= 0) particles.splice(index, 1); });
                     pickups.forEach(p => p.update(dt));
                     attackVisuals.forEach((v, index) => { v.update(dt); if(v.life <= 0) attackVisuals.splice(index, 1); });

                     if(currentTime - lastPickupSpawnTime > PICKUP_SPAWN_INTERVAL) { if(pickups.filter(p=>p.active).length < 2) { const spawnX = Math.random()*(worldWidth*0.85) + worldWidth*0.075; let spawnY = floorY - 48; let spawnOnPlatform = Math.random()<0.6 && platforms.length>0; if(spawnOnPlatform){ let plat = platforms[Math.floor(Math.random()*platforms.length)]; spawnY = plat.position.y - 48;} pickups.push(new Pickup(spawnX, spawnY)); lastPickupSpawnTime = currentTime;}}
                     pickups.forEach((pickup) => { if (pickup.active && pickup.checkCollision(player)) player.collectPickup(pickup); if (pickup.active && pickup.checkCollision(opponent)) opponent.collectPickup(pickup);}); pickups = pickups.filter(p => p.active);

                     // --- Collisions ---
                     let playerHitSuccessful = false; let opponentHitSuccessful = false;
                     if (player.isAttacking && rectangularCollision({ attacker: player, target: opponent })) { opponentHitSuccessful = opponent.takeHit(ATTACK_DAMAGE, false, player); if(opponentHitSuccessful) hitCount++; player.isAttacking = false; }
                     if (player.isPerformingSpecial && checkSpecialDashCollision({attacker: player, target: opponent})) { opponentHitSuccessful = opponent.takeHit(SPECIAL_ATTACK_DAMAGE, true, player); if(opponentHitSuccessful) hitCount+=2; player.specialDash = false; player.velocity.x *= 0.1; }
                     if (opponent.isAttacking && rectangularCollision({ attacker: opponent, target: player })) { playerHitSuccessful = player.takeHit(ATTACK_DAMAGE, false, opponent); opponent.isAttacking = false; }
                     if (opponent.isPerformingSpecial && checkSpecialDashCollision({attacker: opponent, target: player})) { playerHitSuccessful = player.takeHit(SPECIAL_ATTACK_DAMAGE, true, opponent); opponent.specialDash = false; opponent.velocity.x *= 0.1; }
                     if (player.health <= 0 || opponent.health <= 0) { if(!gameIsOver) determineWinner({ player, opponent, timerId }); gameIsOver=true; }

                 } else if (!gameIsOver) { // Update minimal elements if in Menu/GameOver state before starting
                    pickups.forEach(p => p.update(dt)); attackVisuals.forEach((v,index)=>{ v.update(dt); if(v.life <=0) attackVisuals.splice(index,1);});
                 }
             }

             // ---- Drawing Logic ---- (Always runs, using the potentially stale visual state during hit lag)
             ctx.save();
             if (screenShake.duration > 0 && gamePausedForHitLag <=0) { // Apply shake only if game isn't paused
                const shakeX=(Math.random()-0.5)*2*screenShake.intensity; const shakeY=(Math.random()-0.5)*2*screenShake.intensity;
                ctx.translate(shakeX, shakeY);
                screenShake.duration -= dt * 1000; // Decrement using dt for consistency
                if(screenShake.duration <= 0) screenShake.intensity=0;
              } else { screenShake.intensity = 0; }
              const camX = Math.round(camera.x);
              drawBackground(camX); platforms.forEach(p => p.draw(camX)); pickups.forEach(p => p.draw(camX));
              player.drawCharacter(camX); opponent.drawCharacter(camX); attackVisuals.forEach(v => v.draw(camX)); particles.forEach(p => p.draw(camX)); foregroundElements.forEach(fe => fe.draw(camX));
              ctx.restore();

              // Request next frame
             requestAnimationFrame(gameLoop);
         }

        function determineWinner({ player, opponent, timerId }) { clearTimeout(timerId); clearTimeout(aiActionTimeout); gameState = 'GAME_OVER'; messageCenter.classList.add('show'); screenShake.intensity = 0; gamePausedForHitLag=0; gameIsOver=true; const finalScore = calculateScore(); scoreDisplay.innerHTML = `Score final : ${finalScore}`; let msg = ''; if (player.health <= 0 && opponent.health <= 0) { msg = `ÉGALITÉ!<br>Appuyez Entrée`; } else if (opponent.health <= 0) { msg = `VICTOIRE ROYALE!<br>Appuyez Entrée`; } else if (player.health <= 0) { msg = `DÉFAITE HONORABLE...<br>Appuyez Entrée`; } else { msg = (player.health > opponent.health ? 'Gagné par Score!' : 'Perdu par Score...') + `<br>Appuyez Entrée`; } messageCenter.childNodes[0].nodeValue = msg; }
        function decreaseTimer() { if (timer > 0 && gameState === 'PLAYING' && !gameIsOver && gamePausedForHitLag <= 0) { timerId = setTimeout(decreaseTimer, 1000); timer--; timerElement.textContent = timer.toString().padStart(2, '0'); } else if (timer <= 0 && gameState === 'PLAYING' && !gameIsOver) { determineWinner({ player, opponent, timerId }); gameIsOver = true;} else if (gameState === 'PLAYING' && !gameIsOver && gamePausedForHitLag > 0) { timerId = setTimeout(decreaseTimer, gamePausedForHitLag + 50); }}

         window.addEventListener('keydown', (event) => { const key = event.key.toLowerCase(); // Check block control without preventing others initially
           if (key === player.controls.block) { keys[key] = true; } if (gameState === 'PLAYING' && player.health > 0 && !player.isStunned) { if (!player.isAI) { if (key === player.controls.left || key === player.controls.right) { keys[key] = true; player.lastkey = key; } else if (key === player.controls.jump || key === player.controls.attack || key === player.controls.special) { keys[key] = true; }}} else if (gameState === 'MENU' || gameState === 'GAME_OVER') { if (key === 'enter') { resetGame(); gameState = 'PLAYING'; messageCenter.classList.remove('show'); decreaseTimer(); lastFrameTime = performance.now();}} });
        window.addEventListener('keyup', (event) => { const key = event.key.toLowerCase(); // Make sure key state reflects release
           keys[key] = false; if (!player.isAI && gameState === 'PLAYING') { if((key === player.controls.left || key === player.controls.right) && !keys[player.controls.left] && !keys[player.controls.right]){ player.lastkey = ''; } // Clear last direction key if both released
                // Handle block release (important to clear state correctly)
                 if(key === player.controls.block && player.isBlocking) {
                     player.isBlocking = false; player.parryWindowActive = false; player.canAttack = true; player.canUseSpecial = true;
                 }
             }
        });


        window.onload = () => { lastFrameTime = performance.now(); resetGame(); gameState = 'MENU'; messageCenter.childNodes[0].nodeValue = 'Le Grand Duel - Entrée'; scoreDisplay.innerHTML=''; messageCenter.classList.add('show'); gameLoop(performance.now()); };

    </script>
</body>
</html>
