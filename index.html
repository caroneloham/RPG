<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Dungeon Crawler Complet</title>
    <style>
        /* --- Palette & Variables --- */
        :root {
            --bg-dark: #1a1a1a; --bg-medium: #2c2c2c; --bg-light: #3f3f3f;
            --text-light: #e0e0e0; --text-medium: #aaaaaa; --text-dark: #111111;
            --border-color: #555555; --accent-color: #ffb74d; --gold-color: #ffd700;
            --player-color: #4caf50; --enemy-color-base: #f44336; --enemy-color-alt1: #ff9800;
            --enemy-color-alt2: #e91e63; --wall-color: #795548; --floor-color: #424242;
            --exit-color: #2196F3; --potion-color: #00bcd4; --hp-color: #4caf50;
            --mp-color: #2196F3; --xp-color: #ffc107; --modal-backdrop: rgba(0, 0, 0, 0.7);
        }
        /* --- Styles Généraux --- */
        body { font-family: Georgia, serif; background-color: var(--bg-dark); color: var(--text-light); display: flex; justify-content: center; align-items: flex-start; padding-top: 20px; line-height: 1.5; font-size: 16px; }
        #game-container { display: flex; flex-direction: column; border: 2px solid var(--border-color); padding: 15px; background-color: var(--bg-medium); min-width: 700px; max-width: 900px; box-shadow: 0 0 15px rgba(0,0,0,0.5); }
        h1, h2, h3 { color: var(--accent-color); margin-top: 0; text-align: center; }
        h3 { border-bottom: 1px solid var(--border-color); padding-bottom: 5px; margin-bottom: 10px; color: var(--text-medium); }
        /* --- Layout Principal (Flexbox) --- */
        #game-screen { display: flex; width: 100%; margin-bottom: 15px; min-height: 400px; }
        #main-view-area { flex-grow: 1; display: flex; flex-direction: column; margin-right: 15px; }
        #main-view { flex-grow: 1; border: 1px solid var(--border-color); padding: 15px; background-color: var(--bg-dark); display: flex; justify-content: center; align-items: center; min-height: 300px; overflow: auto; margin-bottom: 10px; }
        /* Styles pour les différentes vues */
        #map-display, #combat-display, #inventory-display, #skills-display { font-family: 'Courier New', Courier, monospace; font-size: 18px; white-space: pre; line-height: 1.2; width: 100%; height: 100%; color: var(--text-light); }
        #combat-display, #inventory-display, #skills-display { white-space: normal; font-family: Georgia, serif; }
        .hidden { display: none !important; }
        /* --- Panneau Stats Joueur (Sidebar) --- */
        #player-stats { flex-shrink: 0; width: 240px; border: 1px solid var(--border-color); padding: 15px; background-color: var(--bg-dark); }
        #player-stats p { margin: 8px 0; font-size: 14px; display: flex; align-items: center; }
        #player-stats p > span:first-child { margin-right: 8px; font-size: 1.2em; display: inline-block; width: 20px; text-align: center; }
        .stat-bar-container { background-color: var(--floor-color); border: 1px solid var(--border-color); height: 12px; border-radius: 3px; margin-top: 4px; overflow: hidden; }
        .stat-bar { height: 100%; border-radius: 2px; transition: width 0.3s ease-in-out; text-align: center; font-size: 9px; line-height: 12px; color: rgba(0,0,0,0.7); font-weight: bold; }
        .hp-bar { background-color: var(--hp-color); } .mp-bar { background-color: var(--mp-color); } .xp-bar { background-color: var(--xp-color); }
        .flash-damage { animation: flashRed 0.4s ease-out; } @keyframes flashRed { 0%, 100% { box-shadow: none; } 50% { box-shadow: 0 0 10px 3px red; } }
        /* --- Journal des Messages --- */
        #message-log { height: 120px; border: 1px solid var(--border-color); padding: 10px; overflow-y: scroll; background-color: var(--bg-dark); font-size: 13px; color: var(--text-medium); }
        #message-log h3 { margin-bottom: 5px; } #message-log p { margin: 0 0 5px 0; padding: 0; }
        /* --- Styles des Tuiles de Jeu --- */
        .tile { display: inline-block; width: 1.2em; text-align: center; transition: transform 0.1s ease-out; }
        .tile-floor { color: var(--floor-color); } .tile-wall { color: var(--wall-color); font-weight: bold; }
        .tile-player { color: var(--player-color); font-weight: bold; transform: scale(1.1); }
        .tile-enemy-g { color: var(--enemy-color-base); font-weight: bold; } .tile-enemy-s { color: var(--enemy-color-alt1); font-weight: bold; }
        .tile-enemy-o { color: var(--enemy-color-alt2); font-weight: bold; } .tile-enemy-b { color: #f0f; font-weight: bold; transform: scale(1.2);}
        .tile-gold { color: var(--gold-color); } .tile-potion { color: var(--potion-color); } .tile-exit { color: var(--exit-color); font-weight: bold; }
        .tile-hub-inn { color: var(--mp-color); font-weight: bold; } .tile-hub-dungeon { color: var(--accent-color); font-weight: bold; }
        /* --- Contrôles & Boutons --- */
        #controls { text-align: center; margin-top: 10px; }
        #controls button, .action-button, .shop-button, .skill-button, .inventory-button, .modal-button { background-color: var(--bg-light); color: var(--text-light); border: 1px solid var(--border-color); padding: 8px 15px; margin: 5px; cursor: pointer; font-family: inherit; font-size: 14px; border-radius: 4px; transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease; }
        #controls button:hover, .action-button:hover, .shop-button:hover, .skill-button:hover, .inventory-button:hover, .modal-button:hover { background-color: var(--accent-color); color: var(--text-dark); }
        #controls button:active, .action-button:active, .shop-button:active, .skill-button:active, .inventory-button:active, .modal-button:active { transform: translateY(1px); }
        #controls button:disabled, .shop-button:disabled, .modal-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: var(--bg-light); color: var(--text-medium); }
        #controls button:disabled:hover { background-color: var(--bg-light); color: var(--text-medium); }
        #location-info { display: block; margin-top: 10px; font-size: 13px; color: var(--text-medium); text-align: center; }
        /* --- Écran de Combat --- */
        #combat-display { display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .combat-participants { display: flex; justify-content: space-around; width: 100%; margin-bottom: 20px; }
        .combatant-info { border: 1px dashed var(--border-color); padding: 15px; min-width: 180px; text-align: center; background-color: rgba(0,0,0,0.2); border-radius: 5px; }
        .combat-actions button { margin: 8px; }
        #combat-skill-selection, #combat-item-selection { margin-top: 15px; padding: 10px; border: 1px dotted var(--border-color); background-color: rgba(0,0,0,0.1); border-radius: 4px; }
        #combat-skill-selection h4, #combat-item-selection h4 { margin-top: 0; }
        /* --- Listes (Inventaire, Compétences) --- */
        .list-item { margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px dotted var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .list-item:last-child { border-bottom: none; } .list-item span { margin-right: 10px; } .list-item strong { color: var(--accent-color); }
        .list-item em { color: var(--text-medium); font-style: normal; } .list-item button { margin-left: auto; }
        /* --- Boutique Modale --- */
        #modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--modal-backdrop); z-index: 998; display: none; }
        #shop-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 650px; max-height: 85vh; background-color: var(--bg-medium); border: 2px solid var(--border-color); border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.6); z-index: 999; display: none; flex-direction: column; }
        #shop-content { padding: 20px; overflow-y: auto; flex-grow: 1; }
        #shop-modal h2 { margin: 0; padding: 15px 20px; background-color: var(--bg-dark); border-bottom: 1px solid var(--border-color); border-radius: 8px 8px 0 0; font-size: 1.5em; }
        .shop-category h3 { margin-top: 20px; margin-bottom: 10px; color: var(--accent-color); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        .shop-item { display: flex; align-items: center; justify-content: space-between; padding: 10px 5px; border-bottom: 1px dotted var(--border-color); transition: background-color 0.2s ease; }
        .shop-item:last-child { border-bottom: none; } .shop-item:hover { background-color: var(--bg-light); }
        .shop-item-info { flex-grow: 1; margin: 0 10px; } .shop-item-name { font-weight: bold; color: var(--text-light); }
        .shop-item-effect { font-size: 0.9em; color: var(--text-medium); margin-left: 5px; }
        .shop-item-cost { color: var(--gold-color); font-weight: bold; margin: 0 10px; } .shop-item-icon { font-size: 1.3em; width: 30px; text-align: center; }
        #shop-player-gold { text-align: right; padding: 0 20px 10px; color: var(--gold-color); font-weight: bold; }
        #shop-modal-controls { padding: 10px 20px; text-align: right; background-color: var(--bg-dark); border-top: 1px solid var(--border-color); border-radius: 0 0 8px 8px; }
        /* Game Over Overlay */
        #game-over-screen { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(100, 0, 0, 0.85); color: #ffdddd; padding: 30px 40px; border: 3px solid #f00; border-radius: 10px; text-align: center; z-index: 1000; box-shadow: 0 0 20px rgba(255, 0, 0, 0.7); }
        #game-over-screen h2 { margin-top: 0; color: #f00; font-size: 2em; }
        #game-over-screen button { background-color: #ccc; color: #333; padding: 10px 20px; font-size: 1em; }
        #game-over-screen button:hover { background-color: #eee; color: #000; }
    </style>
</head>
<body>

    <div id="game-container">
        <h1>Mini Dungeon Crawler</h1>

        <div id="game-screen">
            <div id="main-view-area">
                <div id="main-view">
                    <div id="map-display"></div>
                    <div id="combat-display" class="hidden"></div>
                    <div id="inventory-display" class="hidden"></div>
                    <div id="skills-display" class="hidden"></div>
                </div>
                <div id="message-log"><h3>Log</h3></div>
            </div>
            <div id="player-stats">
                <h3>Joueur</h3>
                <p><span title="Niveau">⭐</span> Niveau: <span id="stat-level">1</span></p>
                <p><span title="Points de Vie">❤️</span> PV: <span id="stat-hp">10</span>/<span id="stat-max-hp">10</span></p>
                <div class="stat-bar-container"><div id="hp-bar" class="stat-bar hp-bar"></div></div>
                <p><span title="Points de Mana">💧</span> PM: <span id="stat-mp">5</span>/<span id="stat-max-mp">5</span></p>
                <div class="stat-bar-container"><div id="mp-bar" class="stat-bar mp-bar"></div></div>
                <p><span title="Expérience">📈</span> XP: <span id="stat-xp">0</span>/<span id="stat-xp-next">100</span></p>
                <div class="stat-bar-container"><div id="xp-bar" class="stat-bar xp-bar"></div></div>
                <p><span title="Attaque">⚔️</span> Attaque: <span id="stat-attack">5</span></p>
                <p><span title="Défense">🛡️</span> Défense: <span id="stat-defense">2</span></p>
                <p><span title="Or">💰</span> Or: <span id="stat-gold">0</span></p>
                <hr style="border-color: var(--border-color); margin: 15px 0;">
                <p><span title="Arme">🗡️</span> Arme: <span id="stat-weapon">Aucune</span></p>
                <p><span title="Armure">👕</span> Armure: <span id="stat-armor">Aucune</span></p>
            </div>
        </div>

        <div id="controls">
            <button onclick="GameManager.toggleInventory()">Inventaire</button>
            <button onclick="GameManager.toggleSkills()">Compétences</button>
            <button id="shop-btn" onclick="GameManager.enterShop()">Boutique</button>
            <button id="return-hub-btn" onclick="GameManager.returnToHub()">Retour Village</button>
            <button onclick="GameManager.saveGame()">Sauvegarder</button>
            <button onclick="GameManager.loadGame()">Charger</button>
        </div>
        <span id="location-info">Lieu: Village</span>

        <div id="game-over-screen" class="hidden"> <h2>GAME OVER</h2> <p>Vous avez été vaincu.</p> <button onclick="GameManager.loadGame(); GameManager.hideGameOver()">Charger</button> </div>

        <div id="modal-backdrop"></div>
        <div id="shop-modal">
             <h2><span id="shop-title-icon">🏪</span> Boutique</h2>
            <div id="shop-content"></div>
             <div id="shop-player-gold"> Votre Or : 💰 <span id="shop-gold-display">0</span> </div>
            <div id="shop-modal-controls"> <button id="close-shop-btn" class="modal-button" onclick="GameManager.exitShop()">Fermer</button> </div>
        </div>
    </div>

    <script>
        // --- Constants ---
        const TILE = { FLOOR: '.', WALL: '🧱', PLAYER: '🚶', EXIT: '🚪', GOLD: '💰', POTION: '✨', ENEMY_GOBLIN: '👹', ENEMY_SKELETON: '💀', ENEMY_ORC: '👺', ENEMY_BOSS: '😈', HUB_INN: '🛌', HUB_DUNGEON_1: '①', HUB_DUNGEON_2: '②' };
        const GAME_STATE = { EXPLORING: 'exploring', COMBAT: 'combat', HUB: 'hub', SHOP: 'shop', INVENTORY: 'inventory', SKILLS: 'skills', GAME_OVER: 'gameOver' };
        const PLAYER_BASE_STATS = { hp: 30, mp: 10, attack: 5, defense: 2 };
        const LEVEL_XP_REQUIREMENT = [0, 100, 250, 500, 1000, 2000];

        // --- Game Data ---
        const Items = { 'w_dagger': { name: "Dague", type: 'weapon', attack: 2, cost: 50, icon: '🗡️' }, 'w_sword': { name: "Épée Courte", type: 'weapon', attack: 5, cost: 150, icon: '⚔️' }, 'w_axe': { name: "Hache", type: 'weapon', attack: 8, cost: 300, icon: '🪓' }, 'w_staff': { name: "Bâton Magique", type: 'weapon', attack: 4, mpBonus: 5, cost: 500, icon: '🪄' }, 'w_greatsword': { name: "Espadon", type: 'weapon', attack: 12, cost: 800, icon: '🔪' }, 'a_leather': { name: "Cuir", type: 'armor', defense: 2, cost: 75, icon: '👕' }, 'a_studded': { name: "Cuir Clouté", type: 'armor', defense: 4, cost: 150, icon: '🧥'}, 'a_chain': { name: "Mailles", type: 'armor', defense: 6, cost: 300, icon: '⛓️' }, 'a_plate': { name: "Plaques", type: 'armor', defense: 9, cost: 600, icon: '🛡️' }, 'a_fullplate': { name: "Harnois", type: 'armor', defense: 12, cost: 1000, icon: '🏰'}, 'p_heal_s': { name: "Potion Soin (P)", type: 'potion', effect: 'heal', value: 20, cost: 30, icon: '❤️' }, 'p_mana_s': { name: "Potion Mana (P)", type: 'potion', effect: 'mana', value: 15, cost: 40, icon: '💧' }, };
        const Skills = { 's_power_strike': { name: "Frappe Puissante", type: 'active', mpCost: 3, effect: 'damage', multiplier: 1.5, target: 'enemy', cost: 100, icon: '💥' }, 's_quick_block': { name: "Parade Rapide", type: 'active', mpCost: 2, effect: 'defense_boost', value: 5, duration: 1, target: 'player', cost: 150, icon: '🛡️' }, 's_heal_light': { name: "Soin Léger", type: 'active', mpCost: 4, effect: 'heal', value: 25, target: 'player', cost: 250, icon: '❤️‍🩹' }, 's_focus': { name: "Focalisation", type: 'passive', effect: 'stat_boost', stat: 'maxMp', value: 5, cost: 400, icon: '🧠' }, 's_toughness': { name: "Robustesse", type: 'passive', effect: 'stat_boost', stat: 'maxHp', value: 10, cost: 500, icon: '💪' }, 's_fireball': { name: "Boule de Feu", type: 'active', mpCost: 5, effect: 'magic_damage', baseDamage: 10, target: 'enemy', cost: 750, icon: '🔥' }, 's_heavy_strike': { name: "Frappe Lourde", type: 'active', mpCost: 5, effect: 'damage', multiplier: 2.0, target: 'enemy', cost: 1100, icon: '🔨' }, 's_battle_focus': { name: "Concentration", type: 'passive', effect: 'stat_boost', stat: 'attack', value: 1, cost: 1500, icon: '🎯' }, 's_divine_blessing': { name: "Bénédiction", type: 'active', mpCost: 10, effect: 'heal', value: 60, target: 'player', cost: 1800, icon: '🌟' }, 's_master_defense': { name: "Maître Défenseur", type: 'passive', effect: 'stat_boost', stat: 'defense', value: 2, cost: 2000, icon: '🧱' } };
        const Enemies = { 'goblin': { name: "Gobelin", tile: TILE.ENEMY_GOBLIN, hp: 15, attack: 4, defense: 1, xp: 15, gold: 5, skills: [] }, 'skeleton': { name: "Squelette", tile: TILE.ENEMY_SKELETON, hp: 25, attack: 6, defense: 3, xp: 30, gold: 15, skills: [] }, 'orc': { name: "Orc", tile: TILE.ENEMY_ORC, hp: 40, attack: 8, defense: 4, xp: 50, gold: 30, skills: ['s_power_strike'] }, 'boss_troll': { name: "Troll Gardien", tile: TILE.ENEMY_BOSS, hp: 100, attack: 12, defense: 6, xp: 200, gold: 150, skills: ['s_power_strike'] } };
        const Dungeons = { "hub": { name: "Village", map: ["🧱🧱🧱🧱🧱🧱🧱🧱🧱🧱🧱🧱🧱","🧱...........①.🧱","🧱.🧱🧱🧱.🧱🧱🧱🧱🧱🧱🧱.🧱","🧱.🧱.🧱.🧱🛌....🧱.🧱","🧱.🧱🧱🧱.🧱🧱🧱🧱🧱🧱🧱.🧱","🧱...........②.🧱","🧱🧱🧱🧱🧱🧱🧱🧱🧱🧱🧱🧱🧱"], fixed: true, enemies: {}, items: {} }, "dungeon1": { name: "Forêt Sombre", floors: 2, mapGenerator: () => generateSimpleDungeon(15, 10, 1, 3, 1), bossFloor: null }, "dungeon2": { name: "Cavernes Oubliées", floors: 3, mapGenerator: (floor) => generateSimpleDungeon(20, 15, floor, 4 + floor, 2 + floor), bossFloor: 3, bossType: 'boss_troll' } };

        // --- Game State Variables ---
        let player; let currentDungeon = { id: null, floor: 0, map: [], enemies: {}, items: {} }; let gameState = GAME_STATE.HUB; let combatState = { active: false, enemy: null, enemyCurrentHp: 0, playerTempDefense: 0 }; let messageLog = [];

        // --- DOM Elements ---
        const mapDisplay = document.getElementById('map-display'); const combatDisplay = document.getElementById('combat-display'); const shopContent = document.getElementById('shop-content'); const shopModal = document.getElementById('shop-modal'); const modalBackdrop = document.getElementById('modal-backdrop'); const inventoryDisplay = document.getElementById('inventory-display'); const skillsDisplay = document.getElementById('skills-display'); const mainViewDivs = [mapDisplay, combatDisplay, inventoryDisplay, skillsDisplay]; const statLevel = document.getElementById('stat-level'); const statXP = document.getElementById('stat-xp'); const statXPNext = document.getElementById('stat-xp-next'); const statHP = document.getElementById('stat-hp'); const statMaxHP = document.getElementById('stat-max-hp'); const statMP = document.getElementById('stat-mp'); const statMaxMP = document.getElementById('stat-max-mp'); const statAttack = document.getElementById('stat-attack'); const statDefense = document.getElementById('stat-defense'); const statGold = document.getElementById('stat-gold'); const statWeapon = document.getElementById('stat-weapon'); const statArmor = document.getElementById('stat-armor'); const hpBar = document.getElementById('hp-bar'); const mpBar = document.getElementById('mp-bar'); const xpBar = document.getElementById('xp-bar'); const playerStatsPanel = document.getElementById('player-stats'); const messageLogElement = document.getElementById('message-log'); const locationInfo = document.getElementById('location-info'); const gameOverScreen = document.getElementById('game-over-screen'); const shopGoldDisplay = document.getElementById('shop-gold-display'); const returnHubBtn = document.getElementById('return-hub-btn'); const shopBtn = document.getElementById('shop-btn');

        // --- Utility Functions ---
        function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function logMessage(message) { console.log(message); messageLog.unshift(message); if (messageLog.length > 20) { messageLog.pop(); } renderLog(); }
        function showView(viewElement) { mainViewDivs.forEach(div => div.classList.add('hidden')); if (viewElement) { viewElement.classList.remove('hidden'); } if (gameState === GAME_STATE.SHOP) { shopModal.style.display = 'flex'; modalBackdrop.style.display = 'block'; } else { shopModal.style.display = 'none'; modalBackdrop.style.display = 'none'; } }

        // --- Rendering Functions ---
        function renderAll() { renderStats(); renderLocationInfo(); GameManager.updateButtonStates(); switch (gameState) { case GAME_STATE.HUB: showView(mapDisplay); renderDungeon(); break; case GAME_STATE.EXPLORING: showView(mapDisplay); renderDungeon(); break; case GAME_STATE.COMBAT: showView(combatDisplay); renderCombat(); break; case GAME_STATE.SHOP: showView(null); renderShop(); break; case GAME_STATE.INVENTORY: showView(inventoryDisplay); renderInventory(); break; case GAME_STATE.SKILLS: showView(skillsDisplay); renderSkills(); break; case GAME_STATE.GAME_OVER: showView(null); gameOverScreen.classList.remove('hidden'); break; default: showView(mapDisplay); renderDungeon(); } if (gameState !== GAME_STATE.GAME_OVER) { gameOverScreen.classList.add('hidden'); } }
        function renderStats() { const calculatedStats = calculatePlayerStats(); const currentXP = player.xp; const nextLevelXP = LEVEL_XP_REQUIREMENT[player.level] || Infinity; statLevel.textContent = player.level; statXP.textContent = currentXP; statXPNext.textContent = LEVEL_XP_REQUIREMENT[player.level] || 'MAX'; statHP.textContent = player.hp; statMaxHP.textContent = calculatedStats.maxHp; statMP.textContent = player.mp; statMaxMP.textContent = calculatedStats.maxMp; statAttack.textContent = calculatedStats.attack; statDefense.textContent = calculatedStats.defense; statGold.textContent = player.gold; statWeapon.textContent = player.equipment.weapon ? Items[player.equipment.weapon].name : 'Aucune'; statArmor.textContent = player.equipment.armor ? Items[player.equipment.armor].name : 'Aucune'; const hpPercent = calculatedStats.maxHp > 0 ? (player.hp / calculatedStats.maxHp) * 100 : 0; const mpPercent = calculatedStats.maxMp > 0 ? (player.mp / calculatedStats.maxMp) * 100 : 0; const xpPercent = nextLevelXP !== Infinity && nextLevelXP > 0 ? (currentXP / nextLevelXP) * 100 : (player.level >= LEVEL_XP_REQUIREMENT.length -1 ? 100 : 0); hpBar.style.width = `${hpPercent}%`; mpBar.style.width = `${mpPercent}%`; xpBar.style.width = `${xpPercent}%`; hpBar.textContent = `${player.hp}/${calculatedStats.maxHp}`; mpBar.textContent = `${player.mp}/${calculatedStats.maxMp}`; xpBar.textContent = nextLevelXP !== Infinity ? `${currentXP}/${nextLevelXP}` : 'MAX'; }
        function renderLocationInfo() { let locationName = "Inconnu"; if (gameState === GAME_STATE.HUB || currentDungeon.id === 'hub') { locationName = Dungeons['hub'].name; } else if (currentDungeon.id && Dungeons[currentDungeon.id]) { locationName = `${Dungeons[currentDungeon.id].name} - Étage ${currentDungeon.floor}`; } locationInfo.textContent = `Lieu: ${locationName}`; }
        function renderLog() { messageLogElement.innerHTML = '<h3>Log</h3>' + messageLog.map(msg => `<p>${msg}</p>`).join(''); messageLogElement.scrollTop = 0; }
        function renderDungeon() { let mapHTML = ''; for (let y = 0; y < currentDungeon.map.length; y++) { for (let x = 0; x < currentDungeon.map[y].length; x++) { const posKey = `${x},${y}`; let mapChar = currentDungeon.map[y][x]; let displayChar = mapChar; let tileClass = ''; let isOverridden = false; if (player.pos.x === x && player.pos.y === y) { tileClass = 'tile-player'; displayChar = TILE.PLAYER; isOverridden = true; } else if (currentDungeon.enemies[posKey]) { const enemyType = currentDungeon.enemies[posKey].type; displayChar = Enemies[enemyType].tile; if(displayChar === TILE.ENEMY_GOBLIN) tileClass = 'tile-enemy-g'; else if(displayChar === TILE.ENEMY_SKELETON) tileClass = 'tile-enemy-s'; else if(displayChar === TILE.ENEMY_ORC) tileClass = 'tile-enemy-o'; else if(displayChar === TILE.ENEMY_BOSS) tileClass = 'tile-enemy-b'; else tileClass = 'tile-enemy-g'; isOverridden = true; } else if (currentDungeon.items[posKey]) { const item = currentDungeon.items[posKey]; if (item.type === 'gold') { tileClass = 'tile-gold'; displayChar = TILE.GOLD; } else if (item.type === 'potion') { tileClass = 'tile-potion'; displayChar = TILE.POTION; } isOverridden = true; } if (!isOverridden) { switch (mapChar) { case TILE.WALL: tileClass = 'tile-wall'; break; case TILE.FLOOR: tileClass = 'tile-floor'; displayChar = ' '; break; case TILE.EXIT: tileClass = 'tile-exit'; break; case TILE.HUB_INN: tileClass = 'tile-hub-inn'; break; case TILE.HUB_DUNGEON_1: tileClass = 'tile-hub-dungeon'; break; case TILE.HUB_DUNGEON_2: tileClass = 'tile-hub-dungeon'; break; default: tileClass = 'tile-floor'; displayChar = '?'; } } tileClass = `tile ${tileClass}`; mapHTML += `<span class="${tileClass}" title="${getTileTitle(mapChar, posKey)}">${displayChar}</span>`; } mapHTML += '\n'; } mapDisplay.innerHTML = mapHTML; }
        function getTileTitle(mapChar, posKey) { if (currentDungeon.enemies[posKey]) return Enemies[currentDungeon.enemies[posKey].type].name; if (currentDungeon.items[posKey]) { const item = currentDungeon.items[posKey]; return item.type === 'gold' ? `${item.value} Or` : Items[item.itemId].name; } switch(mapChar) { case TILE.WALL: return "Mur"; case TILE.EXIT: return "Sortie"; case TILE.HUB_INN: return "Auberge"; case TILE.HUB_DUNGEON_1: return Dungeons['dungeon1'].name; case TILE.HUB_DUNGEON_2: return Dungeons['dungeon2'].name; default: return ""; } }
        function renderCombat() { if (!combatState.active || !combatState.enemy) { combatDisplay.innerHTML = "<p>Erreur Combat.</p>"; return; } const enemy = combatState.enemy; const playerStats = calculatePlayerStats(); let combatHTML = `<h2>Combat ! ${enemy.tile}</h2><div class="combat-participants"><div class="combatant-info"><h3>Vous ${TILE.PLAYER}</h3><p>PV: ${player.hp}/${playerStats.maxHp}</p><p>PM: ${player.mp}/${playerStats.maxMp}</p><p>Att: ${playerStats.attack}</p><p>Déf: ${playerStats.defense + combatState.playerTempDefense}</p>${combatState.playerTempDefense > 0 ? '<p>(Défense +'+combatState.playerTempDefense+' Temp.)</p>' : ''}</div><div class="combatant-info"><h3>${enemy.name} ${enemy.tile}</h3><p>PV: ${combatState.enemyCurrentHp}/${enemy.hp}</p><p>Att: ${enemy.attack}</p><p>Déf: ${enemy.defense}</p></div></div><div class="combat-actions"><button class="action-button" onclick="CombatManager.playerAction('attack')">⚔️ Attaquer</button><button class="action-button" onclick="CombatManager.showSkillSelection()">✨ Compétence</button><button class="action-button" onclick="CombatManager.showItemSelection()">🎒 Objet</button><button class="action-button" onclick="CombatManager.playerAction('defend')">🛡️ Défendre</button><button class="action-button" onclick="CombatManager.playerAction('flee')">🏃 Fuir</button></div><div id="combat-skill-selection" class="hidden"></div> <div id="combat-item-selection" class="hidden"></div>`; combatDisplay.innerHTML = combatHTML; }
        function renderShop() { shopGoldDisplay.textContent = player.gold; let shopHTML = ''; const itemCategories = { 'Armes': [], 'Armures': [], 'Consommables': [], 'Compétences': [], 'Vendre': [] }; for (const id in Items) { const item = Items[id]; if (item.type === 'weapon') itemCategories['Armes'].push(id); else if (item.type === 'armor') itemCategories['Armures'].push(id); else if (item.type === 'potion') itemCategories['Consommables'].push(id); } for (const id in Skills) { if (!player.skills.includes(id)) { itemCategories['Compétences'].push(id); } } for(const itemId in player.inventory) { if(player.inventory[itemId] > 0 && Items[itemId] && Items[itemId].type !== 'potion') { if(player.equipment.weapon !== itemId && player.equipment.armor !== itemId) { itemCategories['Vendre'].push(itemId); } } } for (const categoryName in itemCategories) { if (itemCategories[categoryName].length > 0 || categoryName === 'Vendre') { shopHTML += `<div class="shop-category"><h3>${categoryName}</h3>`; if (categoryName === 'Vendre') { shopHTML += '<p>Vendre équipement (50% prix).</p>'; if (itemCategories['Vendre'].length === 0) shopHTML += "<p><i>Rien à vendre.</i></p>"; } itemCategories[categoryName].forEach(id => { let item, cost, effectText, icon, actionButton; const isSelling = categoryName === 'Vendre'; if (isSelling) { item = Items[id]; cost = Math.floor(item.cost * 0.5); effectText = `x ${player.inventory[id]}`; icon = item.icon || '❓'; actionButton = `<button class="shop-button modal-button" onclick="ShopManager.sellItem('${id}')">Vendre 1 (💰 ${cost})</button>`; } else if (categoryName === 'Compétences') { item = Skills[id]; cost = item.cost; effectText = getSkillDescription(item) + (item.type === 'active' ? ` (Coût: ${item.mpCost}💧)` : ''); icon = item.icon || '❓'; const canAfford = player.gold >= cost; actionButton = `<button class="shop-button modal-button" data-item-id="${id}" onclick="ShopManager.learnSkill('${id}')" ${!canAfford ? 'disabled' : ''}>Apprendre</button>`; } else { item = Items[id]; cost = item.cost; if (item.type === 'weapon') effectText = `Att +${item.attack || 0}${item.mpBonus ? ', PM Max +'+item.mpBonus : ''}`; else if (item.type === 'armor') effectText = `Déf +${item.defense || 0}`; else if (item.type === 'potion') effectText = item.effect === 'heal' ? `Soigne ${item.value} PV` : `Rend ${item.value} PM`; else effectText = ''; icon = item.icon || '❓'; const canAfford = player.gold >= cost; actionButton = `<button class="shop-button modal-button" data-item-id="${id}" onclick="ShopManager.buyItem('${id}')" ${!canAfford ? 'disabled' : ''}>Acheter</button>`; } shopHTML += `<div class="shop-item"><span class="shop-item-icon">${icon}</span><div class="shop-item-info"><span class="shop-item-name">${item.name}</span><span class="shop-item-effect">${effectText}</span></div>${!isSelling ? `<span class="shop-item-cost">💰 ${cost}</span>` : ''}${actionButton}</div>`; }); shopHTML += `</div>`; } } shopContent.innerHTML = shopHTML; }
        function renderInventory() { let inventoryHTML = `<h2>🎒 Inventaire</h2><h3>Équipement</h3>`; inventoryHTML += `<div class="list-item"><span>${player.equipment.weapon ? Items[player.equipment.weapon].icon : '·'} Arme: <strong>${player.equipment.weapon ? Items[player.equipment.weapon].name : 'Aucune'}</strong></span>${player.equipment.weapon ? '<button class="inventory-button" onclick="InventoryManager.unequipItem(\'weapon\')">Déséquiper</button>' : ''}</div>`; inventoryHTML += `<div class="list-item"><span>${player.equipment.armor ? Items[player.equipment.armor].icon : '·'} Armure: <strong>${player.equipment.armor ? Items[player.equipment.armor].name : 'Aucune'}</strong></span>${player.equipment.armor ? '<button class="inventory-button" onclick="InventoryManager.unequipItem(\'armor\')">Déséquiper</button>' : ''}</div>`; inventoryHTML += `<h3>Objets</h3>`; let hasItems = false; for (const itemId in player.inventory) { if (player.inventory[itemId] > 0 && Items[itemId]) { hasItems = true; const item = Items[itemId]; inventoryHTML += `<div class="list-item"><span>${item.icon || '?'} <strong>${item.name}</strong> x ${player.inventory[itemId]}</span><span>`; if (item.type === 'weapon' || item.type === 'armor') { inventoryHTML += ` <button class="inventory-button" onclick="InventoryManager.equipItem('${itemId}')">Équiper</button>`; } if (item.type === 'potion') { inventoryHTML += ` <button class="inventory-button" onclick="InventoryManager.usePotion('${itemId}')">Utiliser</button>`; } inventoryHTML += `</span></div>`; } } if (!hasItems) { inventoryHTML += "<p><i>Inventaire vide.</i></p>"; } inventoryHTML += '<hr><button class="modal-button" onclick="GameManager.closeInventory()">Fermer</button>'; inventoryDisplay.innerHTML = inventoryHTML; }
        function renderSkills() { let skillsHTML = `<h2>✨ Compétences</h2>`; if (player.skills.length === 0) { skillsHTML += "<p><i>Aucune compétence connue.</i></p>"; } else { skillsHTML += "<h3>Actives</h3>"; let hasActives = false; player.skills.forEach(skillId => { const skill = Skills[skillId]; if (skill && skill.type === 'active') { hasActives = true; skillsHTML += `<div class="list-item"><span>${skill.icon || '?'} <strong>${skill.name}</strong></span> <em>${getSkillDescription(skill)} (Coût: ${skill.mpCost}💧)</em></div>`; } }); if (!hasActives) skillsHTML += "<p><i>Aucune.</i></p>"; skillsHTML += "<h3>Passives</h3>"; let hasPassives = false; player.skills.forEach(skillId => { const skill = Skills[skillId]; if (skill && skill.type === 'passive') { hasPassives = true; skillsHTML += `<div class="list-item"><span>${skill.icon || '?'} <strong>${skill.name}</strong></span> <em>${getSkillDescription(skill)}</em></div>`; } }); if (!hasPassives) skillsHTML += "<p><i>Aucune.</i></p>"; } skillsHTML += '<hr><button class="modal-button" onclick="GameManager.closeSkills()">Fermer</button>'; skillsDisplay.innerHTML = skillsHTML; }
        function getSkillDescription(skill) { switch(skill.effect) { case 'damage': return `Inflige ${skill.multiplier}x dégâts Attaque.`; case 'magic_damage': return `Inflige ${skill.baseDamage} dégâts magiques.`; case 'heal': return `Restaure ${skill.value} PV.`; case 'stat_boost': let statName = skill.stat; if (skill.stat === 'maxHp') statName = "PV Max"; else if (skill.stat === 'maxMp') statName = "PM Max"; else if (skill.stat === 'attack') statName = "Attaque"; else if (skill.stat === 'defense') statName = "Défense"; return `Augmente ${statName} de ${skill.value}.`; case 'defense_boost': return `Augmente Défense de ${skill.value} (1 tour).`; default: return "Effet inconnu."; } }
        function calculatePlayerStats() { let baseAttack = PLAYER_BASE_STATS.attack + player.levelBonus.attack; let baseDefense = PLAYER_BASE_STATS.defense + player.levelBonus.defense; let baseMaxHp = PLAYER_BASE_STATS.hp + player.levelBonus.maxHp; let baseMaxMp = PLAYER_BASE_STATS.mp + player.levelBonus.maxMp; if (player.equipment.weapon && Items[player.equipment.weapon]) { baseAttack += Items[player.equipment.weapon].attack || 0; baseMaxMp += Items[player.equipment.weapon].mpBonus || 0; } if (player.equipment.armor && Items[player.equipment.armor]) { baseDefense += Items[player.equipment.armor].defense || 0; } player.skills.forEach(skillId => { const skill = Skills[skillId]; if (skill && skill.type === 'passive' && skill.effect === 'stat_boost') { switch(skill.stat) { case 'maxHp': baseMaxHp += skill.value; break; case 'maxMp': baseMaxMp += skill.value; break; case 'attack': baseAttack += skill.value; break; case 'defense': baseDefense += skill.value; break; } } }); return { maxHp: baseMaxHp, maxMp: baseMaxMp, attack: baseAttack, defense: baseDefense }; }
        function generateSimpleDungeon(width, height, floor, maxEnemies, maxItems) { let map = Array.from({ length: height }, () => Array(width).fill(TILE.WALL)); let enemies = {}; let items = {}; let startPos = { x: -1, y: -1 }; let exitPos = { x: -1, y: -1 }; let currentX = Math.floor(width / 2); let currentY = Math.floor(height / 2); map[currentY][currentX] = TILE.FLOOR; startPos = {x: currentX, y: currentY}; let floorTiles = 1; const targetFloorTiles = Math.floor(width * height * 0.4); let directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]; let steps = 0; const maxSteps = width * height * 5; while (floorTiles < targetFloorTiles && steps < maxSteps) { directions.sort(() => Math.random() - 0.5); let moved = false; for (let i = 0; i < directions.length; i++) { let [dx, dy] = directions[i]; let nextX = currentX + dx * 2; let nextY = currentY + dy * 2; if (nextX > 0 && nextX < width - 1 && nextY > 0 && nextY < height - 1) { if (map[currentY + dy][currentX + dx] === TILE.WALL) { map[currentY + dy][currentX + dx] = TILE.FLOOR; floorTiles++; } if (map[nextY][nextX] === TILE.WALL) { map[nextY][nextX] = TILE.FLOOR; floorTiles++; } currentX = nextX; currentY = nextY; moved = true; break; } } if (!moved) { let floorCoords = []; for(let y=1; y < height-1; y++) { for(let x=1; x < width-1; x++) { if (map[y][x] === TILE.FLOOR) floorCoords.push({x, y}); } } if(floorCoords.length > 0){ const randCoord = floorCoords[getRandomInt(0, floorCoords.length - 1)]; currentX = randCoord.x; currentY = randCoord.y; } else { break; } } steps++; } let maxDist = -1; let floorCoords = []; for(let y=1; y < height-1; y++) { for(let x=1; x < width-1; x++) { if (map[y][x] === TILE.FLOOR) { floorCoords.push({x,y}); let dist = Math.abs(x - startPos.x) + Math.abs(y - startPos.y); if (dist > maxDist) { maxDist = dist; exitPos = { x, y }; } } } } if (exitPos.x !== -1) { map[exitPos.y][exitPos.x] = TILE.EXIT; } else { map[currentY][currentX] = TILE.EXIT; exitPos = {x: currentX, y: currentY}; } let enemyCount = 0; let tries = 0; const enemyTypes = floor <= 1 ? ['goblin'] : (floor <= 2 ? ['goblin', 'skeleton'] : ['skeleton', 'orc']); let availableCoords = [...floorCoords]; while(enemyCount < maxEnemies && tries < maxEnemies * 10 && availableCoords.length > 0) { let randIndex = getRandomInt(0, availableCoords.length - 1); let pos = availableCoords[randIndex]; availableCoords.splice(randIndex, 1); if ((pos.x !== startPos.x || pos.y !== startPos.y) && (pos.x !== exitPos.x || pos.y !== exitPos.y)) { const posKey = `${pos.x},${pos.y}`; if (!enemies[posKey] && !items[posKey] && map[pos.y][pos.x] === TILE.FLOOR) { const enemyType = enemyTypes[getRandomInt(0, enemyTypes.length - 1)]; enemies[posKey] = { type: enemyType, originalPos: { ...pos } }; enemyCount++; } } tries++; } const dungeonData = Dungeons[currentDungeon.id]; if (dungeonData && dungeonData.bossFloor === floor && dungeonData.bossType) { let bossPlaced = false; let possibleBossSpots = []; for(let dy = -1; dy <= 1; dy++){ for(let dx = -1; dx <= 1; dx++){ if(Math.abs(dx) + Math.abs(dy) !== 1) continue; let checkX = exitPos.x + dx; let checkY = exitPos.y + dy; const checkKey = `${checkX},${checkY}`; if (checkX > 0 && checkX < width - 1 && checkY > 0 && checkY < height - 1 && map[checkY][checkX] === TILE.FLOOR && !enemies[checkKey] && !items[checkKey]) { possibleBossSpots.push({x: checkX, y: checkY}); } } } if(possibleBossSpots.length > 0) { const bossPos = possibleBossSpots[getRandomInt(0, possibleBossSpots.length-1)]; const bossKey = `${bossPos.x},${bossPos.y}`; enemies[bossKey] = { type: dungeonData.bossType, originalPos: { ...bossPos } }; bossPlaced = true; availableCoords = availableCoords.filter(c => c.x !== bossPos.x || c.y !== bossPos.y); } if (!bossPlaced && availableCoords.length > 0) { let randIndex = getRandomInt(0, availableCoords.length - 1); let pos = availableCoords[randIndex]; availableCoords.splice(randIndex, 1); const posKey = `${pos.x},${pos.y}`; if (!enemies[posKey] && !items[posKey] && map[pos.y][pos.x] === TILE.FLOOR) { enemies[posKey] = { type: dungeonData.bossType, originalPos: { ...pos } }; } } } let itemCount = 0; tries = 0; while(itemCount < maxItems && tries < maxItems * 10 && availableCoords.length > 0) { let randIndex = getRandomInt(0, availableCoords.length - 1); let pos = availableCoords[randIndex]; availableCoords.splice(randIndex, 1); const posKey = `${pos.x},${pos.y}`; if (!enemies[posKey] && !items[posKey] && map[pos.y][pos.x] === TILE.FLOOR) { if (Math.random() < 0.7) { items[posKey] = { type: 'gold', value: getRandomInt(5 * floor, 15 * floor) }; } else { const potionTypes = ['p_heal_s', 'p_mana_s']; const potionId = potionTypes[getRandomInt(0, potionTypes.length - 1)]; items[posKey] = { type: 'potion', itemId: potionId }; } itemCount++; } tries++; } return { map, enemies, items, startPos }; }

        // --- GameManager Object ---
        const GameManager = { initialize: function() { if (!this.loadGame()) { player = { level: 1, xp: 0, hp: PLAYER_BASE_STATS.hp, mp: PLAYER_BASE_STATS.mp, gold: 20, pos: { x: -1, y: -1 }, equipment: { weapon: null, armor: null }, inventory: { 'p_heal_s': 1 }, skills: [], levelBonus: { maxHp: 0, maxMp: 0, attack: 0, defense: 0 } }; this.enterHub(); } else { if (messageLog.length === 0) logMessage("Partie chargée."); } document.addEventListener('keydown', this.handleInput.bind(this)); }, handleInput: function(event) { if (gameState === GAME_STATE.GAME_OVER) return; if (event.key === 'Escape') { if (gameState === GAME_STATE.SHOP) this.exitShop(); else if (gameState === GAME_STATE.INVENTORY) this.closeInventory(); else if (gameState === GAME_STATE.SKILLS) this.closeSkills(); else if (gameState === GAME_STATE.COMBAT) { CombatManager.hideSkillSelection(); CombatManager.hideItemSelection(); } return; } if (gameState === GAME_STATE.EXPLORING || gameState === GAME_STATE.HUB) { let dx = 0, dy = 0; switch (event.key) { case 'ArrowUp': dy = -1; break; case 'ArrowDown': dy = 1; break; case 'ArrowLeft': dx = -1; break; case 'ArrowRight': dx = 1; break; default: return; } event.preventDefault(); this.movePlayer(dx, dy); } }, movePlayer: function(dx, dy) { const newX = player.pos.x + dx; const newY = player.pos.y + dy; if (newY < 0 || newY >= currentDungeon.map.length || newX < 0 || newX >= currentDungeon.map[0].length) return; const targetTile = currentDungeon.map[newY][newX]; const targetPosKey = `${newX},${newY}`; if (targetTile === TILE.WALL) { logMessage("Mur."); return; } if (currentDungeon.enemies[targetPosKey]) { CombatManager.startCombat(currentDungeon.enemies[targetPosKey].type, targetPosKey); return; } if (targetTile === TILE.EXIT) { this.changeFloor(currentDungeon.floor + 1); return; } if (currentDungeon.id === 'hub') { if (targetTile === TILE.HUB_INN) { this.useInn(); return; } if (targetTile === TILE.HUB_DUNGEON_1) { this.enterDungeon('dungeon1'); return; } if (targetTile === TILE.HUB_DUNGEON_2) { this.enterDungeon('dungeon2'); return; } } player.pos.x = newX; player.pos.y = newY; if (currentDungeon.items[targetPosKey]) { const item = currentDungeon.items[targetPosKey]; if (item.type === 'gold') { player.gold += item.value; logMessage(`+${item.value} ${TILE.GOLD}`); } else if (item.type === 'potion') { InventoryManager.addInventoryItem(item.itemId, 1); logMessage(`Trouvé ${Items[item.itemId].icon}`); } delete currentDungeon.items[targetPosKey]; } renderAll(); }, changeFloor: function(newFloor) { const dungeonData = Dungeons[currentDungeon.id]; if (!dungeonData) { this.enterHub(); return; } if (newFloor > dungeonData.floors) { logMessage(`${dungeonData.name} terminé !`); this.enterHub(); } else { logMessage(`${newFloor > currentDungeon.floor ? 'Descend' : 'Monte'} étage ${newFloor}...`); currentDungeon.floor = newFloor; const generated = dungeonData.mapGenerator(newFloor); currentDungeon.map = generated.map; currentDungeon.enemies = generated.enemies; currentDungeon.items = generated.items; player.pos = { ...generated.startPos }; gameState = GAME_STATE.EXPLORING; this.saveGame(); } renderAll(); }, enterDungeon: function(dungeonId) { const dungeonData = Dungeons[dungeonId]; if (!dungeonData || dungeonData.fixed) { return; } logMessage(`Entre dans ${dungeonData.name}...`); currentDungeon.id = dungeonId; currentDungeon.floor = 1; const generated = dungeonData.mapGenerator(1); currentDungeon.map = generated.map; currentDungeon.enemies = generated.enemies; currentDungeon.items = generated.items; player.pos = { ...generated.startPos }; gameState = GAME_STATE.EXPLORING; this.saveGame(); renderAll(); }, enterHub: function() { currentDungeon.id = 'hub'; currentDungeon.floor = 0; currentDungeon.map = Dungeons['hub'].map.map(row => row.split('')); currentDungeon.enemies = {}; currentDungeon.items = {}; let foundStart = false; for(let y = 0; y < currentDungeon.map.length && !foundStart; y++) { for (let x = 0; x < currentDungeon.map[y].length && !foundStart; x++) { if (currentDungeon.map[y][x] === TILE.FLOOR) { player.pos = { x: x, y: y }; foundStart = true; } } } if(!foundStart) player.pos = {x: 1, y: 1}; gameState = GAME_STATE.HUB; logMessage(`Bienvenue Village ! ${TILE.HUB_INN}: Auberge, ${TILE.HUB_DUNGEON_1}/${TILE.HUB_DUNGEON_2}: Donjons.`); renderAll(); }, enterShop: function() { if (gameState === GAME_STATE.HUB) { logMessage("Ouverture Boutique..."); gameState = GAME_STATE.SHOP; renderAll(); } else { logMessage("Boutique accessible au Village."); } }, exitShop: function() { gameState = GAME_STATE.HUB; renderAll(); }, useInn: function() { const cost = 10; if (player.gold >= cost) { player.gold -= cost; const stats = calculatePlayerStats(); player.hp = stats.maxHp; player.mp = stats.maxMp; logMessage(`Repos ${TILE.HUB_INN} (-${cost} ${TILE.GOLD}). PV/PM Max !`); this.saveGame(); renderAll(); } else { logMessage(`Pas assez d'or (${player.gold}/${cost} ${TILE.GOLD}).`); } }, gainXP: function(amount) { player.xp += amount; logMessage(`+${amount} XP.`); this.checkLevelUp(); }, checkLevelUp: function() { const xpNeeded = LEVEL_XP_REQUIREMENT[player.level]; if (xpNeeded && player.xp >= xpNeeded && player.level < LEVEL_XP_REQUIREMENT.length -1 ) { player.level++; player.xp -= xpNeeded; logMessage(`⭐ Niveau ${player.level} ! ⭐`); const hpGain=getRandomInt(3,6); const mpGain=getRandomInt(1,3); const attackGain=getRandomInt(1,2); const defenseGain=getRandomInt(0,1); player.levelBonus.maxHp += hpGain; player.levelBonus.maxMp += mpGain; player.levelBonus.attack += attackGain; player.levelBonus.defense += defenseGain; const stats=calculatePlayerStats(); player.hp = Math.min(player.hp + Math.ceil(stats.maxHp*0.25), stats.maxHp); player.mp = Math.min(player.mp + Math.ceil(stats.maxMp*0.25), stats.maxMp); logMessage(`Stats + | PV/PM restaurés.`); this.checkLevelUp(); this.saveGame(); renderAll(); } }, toggleInventory: function() { if (gameState === GAME_STATE.INVENTORY) { this.closeInventory(); } else if (gameState === GAME_STATE.EXPLORING || gameState === GAME_STATE.HUB) { gameState = GAME_STATE.INVENTORY; renderAll(); } else { logMessage("Inventaire inaccessible."); } }, closeInventory: function() { if (currentDungeon.id === 'hub') gameState = GAME_STATE.HUB; else gameState = GAME_STATE.EXPLORING; renderAll(); }, toggleSkills: function() { if (gameState === GAME_STATE.SKILLS) { this.closeSkills(); } else if (gameState === GAME_STATE.EXPLORING || gameState === GAME_STATE.HUB) { gameState = GAME_STATE.SKILLS; renderAll(); } else { logMessage("Compétences inaccessibles."); } }, closeSkills: function() { if (currentDungeon.id === 'hub') gameState = GAME_STATE.HUB; else gameState = GAME_STATE.EXPLORING; renderAll(); }, gameOver: function() { logMessage("GAME OVER"); gameState = GAME_STATE.GAME_OVER; renderAll(); }, hideGameOver: function() { gameOverScreen.classList.add('hidden'); }, triggerDamageFlash: function() { playerStatsPanel.classList.add('flash-damage'); setTimeout(() => { playerStatsPanel.classList.remove('flash-damage'); }, 400); }, saveGame: function() { try { const saveData = { player: player, currentDungeonId: currentDungeon.id, currentDungeonFloor: currentDungeon.floor }; localStorage.setItem('dungeonCrawlerSaveData', JSON.stringify(saveData)); logMessage("Partie sauvegardée."); } catch (e) { console.error("Save Error:", e); logMessage("Erreur sauvegarde."); } }, loadGame: function() { try { const savedData = localStorage.getItem('dungeonCrawlerSaveData'); if (savedData) { const loadedData = JSON.parse(savedData); if (!loadedData.player || !loadedData.currentDungeonId) throw new Error("Invalid save data."); player = loadedData.player; currentDungeon.id = loadedData.currentDungeonId; currentDungeon.floor = loadedData.currentDungeonFloor; if(!player.inventory) player.inventory = {}; if(!player.skills) player.skills = []; if(!player.levelBonus) player.levelBonus = { maxHp: 0, maxMp: 0, attack: 0, defense: 0 }; const dungeonData = Dungeons[currentDungeon.id]; if (!dungeonData) { console.error("Corrupt save: Unknown dungeon", currentDungeon.id); this.enterHub(); } else if (dungeonData.fixed) { currentDungeon.map = dungeonData.map.map(row => row.split('')); currentDungeon.enemies = {}; currentDungeon.items = {}; gameState = GAME_STATE.HUB; } else { const generated = dungeonData.mapGenerator(currentDungeon.floor); currentDungeon.map = generated.map; currentDungeon.enemies = generated.enemies; currentDungeon.items = generated.items; gameState = GAME_STATE.EXPLORING; } const stats = calculatePlayerStats(); player.hp = Math.min(player.hp, stats.maxHp); player.mp = Math.min(player.mp, stats.maxMp); messageLog = ["Partie chargée."]; combatState.active = false; this.hideGameOver(); renderAll(); return true; } else { logMessage("Aucune sauvegarde trouvée."); return false; } } catch (e) { console.error("Load Error:", e); logMessage("Erreur chargement. Réinitialisation."); localStorage.removeItem('dungeonCrawlerSaveData'); return false; } }, returnToHub: function() { if (gameState === GAME_STATE.EXPLORING) { logMessage("Retour au village..."); this.enterHub(); } else if (gameState === GAME_STATE.HUB) { logMessage("Déjà au village."); } else { logMessage("Impossible maintenant."); } }, updateButtonStates: function() { if (returnHubBtn) { returnHubBtn.disabled = !(gameState === GAME_STATE.EXPLORING); } if (shopBtn) { shopBtn.disabled = !(gameState === GAME_STATE.HUB); } } };
        const CombatManager = { startCombat: function(enemyType, positionKey) { const enemyTemplate = Enemies[enemyType]; if (!enemyTemplate) return; combatState.active = true; combatState.enemy = { ...enemyTemplate }; combatState.enemyType = enemyType; combatState.enemyPosKey = positionKey; combatState.enemyCurrentHp = enemyTemplate.hp; combatState.playerTurn = true; combatState.playerTempDefense = 0; gameState = GAME_STATE.COMBAT; logMessage(`Combat ${enemyTemplate.tile} ${enemyTemplate.name} !`); renderAll(); }, endCombat: function(victory) { const enemyName = combatState.enemy.name; const enemyTile = combatState.enemy.tile; const enemyPosKey = combatState.enemyPosKey; combatState.active = false; combatState.enemy = null; combatState.enemyPosKey = null; if (victory) { logMessage(`Victoire ${enemyTile} ${enemyName} !`); if (currentDungeon.enemies[enemyPosKey]) delete currentDungeon.enemies[enemyPosKey]; const rewards = Enemies[combatState.enemyType]; if(rewards) { player.gold += rewards.gold; logMessage(`+${rewards.gold} ${TILE.GOLD}.`); GameManager.gainXP(rewards.xp); } if(currentDungeon.id === 'hub') gameState = GAME_STATE.HUB; else gameState = GAME_STATE.EXPLORING; GameManager.saveGame(); } renderAll(); }, playerAction: function(actionType, selection = null) { if (!combatState.active || !combatState.playerTurn) return; const playerStats = calculatePlayerStats(); const enemy = combatState.enemy; let turnEnded = false; combatState.playerTempDefense = 0; switch(actionType) { case 'attack': const playerDamage = Math.max(1, playerStats.attack - enemy.defense + getRandomInt(-1, 1)); combatState.enemyCurrentHp -= playerDamage; logMessage(`⚔️ Attaque ${enemy.tile} (-${playerDamage} PV).`); turnEnded = true; break; case 'skill': const skill = Skills[selection]; if (!skill || skill.type !== 'active') { logMessage("Compétence invalide."); return; } if (player.mp < skill.mpCost) { logMessage("Pas assez de PM !"); return; } player.mp -= skill.mpCost; logMessage(`✨ Utilise ${skill.name} (${skill.icon}) ! (-${skill.mpCost} PM)`); switch(skill.effect) { case 'damage': const skillDamage = Math.max(1, Math.floor((playerStats.attack * skill.multiplier)) - enemy.defense + getRandomInt(-1, 1)); combatState.enemyCurrentHp -= skillDamage; logMessage(`Inflige ${skillDamage} dégâts à ${enemy.tile}.`); break; case 'magic_damage': const magicDamage = Math.max(1, skill.baseDamage + getRandomInt(-2, 2)); combatState.enemyCurrentHp -= magicDamage; logMessage(`Inflige ${magicDamage} dégâts magiques à ${enemy.tile}.`); break; case 'heal': const healed = Math.min(skill.value, playerStats.maxHp - player.hp); player.hp += healed; logMessage(`Récupère ${healed} PV.`); break; case 'defense_boost': combatState.playerTempDefense = skill.value; logMessage(`Défense +${skill.value} (1 tour).`); break; default: logMessage("Effet non implémenté."); break; } turnEnded = true; break; case 'item': const itemId = selection; const item = Items[itemId]; if (!item || item.type !== 'potion' || !player.inventory[itemId] || player.inventory[itemId] <= 0) { logMessage("Objet invalide."); return; } player.inventory[itemId]--; logMessage(`🎒 Utilise ${item.name} (${item.icon}).`); if (item.effect === 'heal') { const healed = Math.min(item.value, playerStats.maxHp - player.hp); player.hp += healed; logMessage(`Récupère ${healed} PV.`); } else if (item.effect === 'mana') { const restored = Math.min(item.value, playerStats.maxMp - player.mp); player.mp += restored; logMessage(`Récupère ${restored} PM.`); } turnEnded = true; break; case 'defend': combatState.playerTempDefense = Math.ceil(playerStats.defense * 0.5); logMessage(`🛡️ Défense (Déf+${combatState.playerTempDefense}).`); turnEnded = true; break; case 'flee': if (Enemies[combatState.enemyType].tile === TILE.ENEMY_BOSS) { logMessage(`Impossible de fuir ${combatState.enemy.name} !`); turnEnded = true; } else if (Math.random() < 0.6) { logMessage("🏃 Fuite réussie !"); combatState.active = false; if (currentDungeon.id === 'hub') gameState = GAME_STATE.HUB; else gameState = GAME_STATE.EXPLORING; renderAll(); return; } else { logMessage("🏃 Fuite échouée !"); turnEnded = true; } break; default: logMessage("Action inconnue."); return; } if (turnEnded) { if (combatState.enemyCurrentHp <= 0) { this.endCombat(true); } else { combatState.playerTurn = false; renderAll(); setTimeout(() => this.enemyTurn(), 800); } } else { renderAll(); } }, enemyTurn: function() { if (!combatState.active || combatState.playerTurn || combatState.enemyCurrentHp <= 0) return; const enemy = combatState.enemy; const playerStats = calculatePlayerStats(); const effectivePlayerDefense = playerStats.defense + combatState.playerTempDefense; let usedSkill = false; if (enemy.skills && enemy.skills.includes('s_power_strike') && Math.random() < 0.3) { const skill = Skills['s_power_strike']; const enemyDamage = Math.max(1, Math.floor((enemy.attack * skill.multiplier)) - effectivePlayerDefense + getRandomInt(-1, 1)); player.hp -= enemyDamage; GameManager.triggerDamageFlash(); logMessage(`${enemy.tile} ${enemy.name} use ${skill.icon} ${skill.name} ! (-${enemyDamage} PV).`); usedSkill = true; } if (!usedSkill) { const enemyDamage = Math.max(1, enemy.attack - effectivePlayerDefense + getRandomInt(-1, 1)); player.hp -= enemyDamage; GameManager.triggerDamageFlash(); logMessage(`${enemy.tile} ${enemy.name} attaque ! (-${enemyDamage} PV).`); } if (player.hp <= 0) { player.hp = 0; renderStats(); GameManager.gameOver(); } else { combatState.playerTurn = true; renderAll(); } }, showSkillSelection: function() { const skillListDiv = document.getElementById('combat-skill-selection'); const itemDiv = document.getElementById('combat-item-selection'); if (!skillListDiv || !itemDiv) return; itemDiv.classList.add('hidden'); skillListDiv.classList.remove('hidden'); let skillHTML = `<h4>Compétence (${player.mp}/${calculatePlayerStats().maxMp}💧):</h4>`; let usableSkills = 0; player.skills.forEach(skillId => { const skill = Skills[skillId]; if (skill && skill.type === 'active') { const canUse = player.mp >= skill.mpCost; skillHTML += `<button class="skill-button modal-button" ${!canUse ? 'disabled' : ''} onclick="CombatManager.selectSkill('${skillId}')">${skill.icon || '?'} ${skill.name} (${skill.mpCost}💧)</button>`; if(canUse) usableSkills++; } }); if (usableSkills === 0 && player.skills.some(id => Skills[id] && Skills[id].type === 'active')) skillHTML += '<p><i>Pas assez de PM.</i></p>'; else if (!player.skills.some(id => Skills[id] && Skills[id].type === 'active')) skillHTML += '<p><i>Aucune.</i></p>'; skillHTML += '<button class="skill-button modal-button" onclick="CombatManager.hideSkillSelection()">Annuler</button>'; skillListDiv.innerHTML = skillHTML; }, hideSkillSelection: function() { const div = document.getElementById('combat-skill-selection'); if (div) div.classList.add('hidden'); }, selectSkill: function(skillId) { this.hideSkillSelection(); this.playerAction('skill', skillId); }, showItemSelection: function() { const itemListDiv = document.getElementById('combat-item-selection'); const skillDiv = document.getElementById('combat-skill-selection'); if (!itemListDiv || !skillDiv) return; skillDiv.classList.add('hidden'); itemListDiv.classList.remove('hidden'); let itemHTML = '<h4>Objet:</h4>'; let usableItems = 0; for(const itemId in player.inventory) { if (player.inventory[itemId] > 0 && Items[itemId] && Items[itemId].type === 'potion') { itemHTML += `<button class="item-button modal-button" onclick="CombatManager.selectItem('${itemId}')">${Items[itemId].icon || '?'} ${Items[itemId].name} (x${player.inventory[itemId]})</button>`; usableItems++; } } if (usableItems === 0) itemHTML += '<p><i>Aucune potion.</i></p>'; itemHTML += '<button class="item-button modal-button" onclick="CombatManager.hideItemSelection()">Annuler</button>'; itemListDiv.innerHTML = itemHTML; }, hideItemSelection: function() { const div = document.getElementById('combat-item-selection'); if (div) div.classList.add('hidden'); }, selectItem: function(itemId) { this.hideItemSelection(); this.playerAction('item', itemId); } };
        const ShopManager = { buyItem: function(itemId) { const item = Items[itemId]; if (!item) return; if (player.gold >= item.cost) { player.gold -= item.cost; InventoryManager.addInventoryItem(itemId, 1); logMessage(`Achat: ${item.icon} ${item.name} (-${item.cost} ${TILE.GOLD}).`); renderShop(); renderStats(); } else { logMessage("Pas assez d'Or !"); } }, sellItem: function(itemId) { const item = Items[itemId]; if (!item || !player.inventory[itemId] || player.inventory[itemId] <= 0) { return; } if(player.equipment.weapon === itemId || player.equipment.armor === itemId) { logMessage(`Déséquipez ${item.name} avant vente.`); return; } const sellPrice = Math.floor(item.cost * 0.5); player.inventory[itemId]--; player.gold += sellPrice; logMessage(`Vente: ${item.icon} ${item.name} (+${sellPrice} ${TILE.GOLD}).`); renderShop(); renderStats(); }, learnSkill: function(skillId) { const skill = Skills[skillId]; if (!skill || player.skills.includes(skillId)) return; if (player.gold >= skill.cost) { player.gold -= skill.cost; player.skills.push(skillId); logMessage(`Appris: ${skill.icon} ${skill.name} (-${skill.cost} ${TILE.GOLD}).`); if (skill.type === 'passive') logMessage(`Effet passif ${skill.name} actif !`); renderShop(); renderAll(); } else { logMessage("Pas assez d'Or !"); } } };
        const InventoryManager = { addInventoryItem: function(itemId, quantity) { if (!Items[itemId]) return; if (!player.inventory[itemId]) player.inventory[itemId] = 0; player.inventory[itemId] += quantity; }, equipItem: function(itemId) { const item = Items[itemId]; if (!item || !player.inventory[itemId] || player.inventory[itemId] <= 0) return; let type = item.type; if (type === 'weapon' || type === 'armor') { let currentEquipped = player.equipment[type]; if (currentEquipped) { this.addInventoryItem(currentEquipped, 1); } player.equipment[type] = itemId; player.inventory[itemId]--; logMessage(`Équipé: ${item.icon} ${item.name}.`); renderAll(); } }, unequipItem: function(type) { let currentEquipped = player.equipment[type]; if(currentEquipped) { const item = Items[currentEquipped]; this.addInventoryItem(currentEquipped, 1); player.equipment[type] = null; logMessage(`Déséquipé: ${item.icon} ${item.name}.`); renderAll(); } }, usePotion: function(itemId) { if (gameState !== GAME_STATE.INVENTORY) { logMessage("Utilisez potions depuis l'inventaire."); return; } const item = Items[itemId]; if (!item || item.type !== 'potion' || !player.inventory[itemId] || player.inventory[itemId] <= 0) return; player.inventory[itemId]--; const playerStats = calculatePlayerStats(); logMessage(`Utilisé: ${item.icon} ${item.name}.`); if (item.effect === 'heal') { const healed = Math.min(item.value, playerStats.maxHp - player.hp); player.hp += healed; logMessage(`+${healed} PV.`); } else if (item.effect === 'mana') { const restored = Math.min(item.value, playerStats.maxMp - player.mp); player.mp += restored; logMessage(`+${restored} PM.`); } renderAll(); } };

        // --- Initialize Game ---
        GameManager.initialize();
    </script>

</body>
</html>
